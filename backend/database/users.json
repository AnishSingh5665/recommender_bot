[
  {
    "code": "from flask import Flask, jsonify\r\nimport requests\r\nimport pandas as pd\r\nfrom datetime import datetime, timedelta\r\nimport influxdb_client\r\nfrom influxdb_client.client.write_api import SYNCHRONOUS\r\n\r\napp = Flask(__name__)\r\n\r\n# API keys and URLs\r\nweather_api_key = \"CY7T7E66YYDD9CE6BAP5JB9BX\"\r\ngeolocation_api_key = \"5d1f894d5b804ff99f0d5c59a62b1875\"\r\ngeolocation_api_url = f\"https://api.ipgeolocation.io/ipgeo?apiKey={geolocation_api_key}\"\r\n\r\n# InfluxDB configuration\r\nbucket = \"Smart_Home_Energy_managment_System\"\r\norg = \"a2eaff1ac168a82f\"\r\ntoken = \"Skuusy-q0tX5VGiMXFGdprkTRnvV_0z4qBcSw292kd9061RplbL3JvYF4yObaTOuEkMRjemPFPzc-vw3xWGVdg==\"\r\nurl = \"https://us-east-1-1.aws.cloud2.influxdata.com\"\r\n\r\n# Initialize InfluxDB client\r\nclient = influxdb_client.InfluxDBClient(\r\n    url=url,\r\n    token=token,\r\n    org=org\r\n)\r\n\r\n# Write API\r\nwrite_api = client.write_api(write_options=SYNCHRONOUS)\r\n\r\ndef get_location():\r\n    response = requests.get(geolocation_api_url)\r\n    if response.status_code == 200:\r\n        data = response.json()\r\n        city_name = data.get('city', '')  # Extract the city name\r\n        return city_name\r\n    else:\r\n        raise Exception(f\"Error fetching location: {response.status_code}\")\r\n\r\ndef fetch_weather_data(city_name):\r\n    city_name='Kanpur'\r\n    weather_url = f\"https://weather.visualcrossing.com/VisualCrossingWebServices/rest/services/timeline/{city_name}?unitGroup=metric&include=days&key={weather_api_key}&contentType=json\"\r\n    response = requests.get(weather_url)\r\n    if response.status_code == 200:\r\n        return response.json()\r\n    else:\r\n        raise Exception(f\"Error fetching weather data: {response.status_code}\")\r\n\r\ndef should_wash_clothes(row):\r\n    score = 0\r\n\r\n    # Precipitation Probability\r\n    if row['precipprob'] > 30:  # Adjusted for UK conditions\r\n        score += 3  # High impact\r\n\r\n    # Humidity\r\n    if row['humidity'] > 75:  # Adjusted threshold\r\n        score += 3  # High impact\r\n\r\n    # Temperature\r\n    if row['temp'] < 10:  # Adjusted for UK climate\r\n        score += 2  # Medium impact\r\n    if row['temp'] > 25:  # Adjusted upper threshold\r\n        score += 1  # High impact\r\n\r\n    # Dew Point\r\n    if row['dew'] > 15:  # Adjusted threshold\r\n        score += 2  # Medium impact\r\n\r\n    # Cloud Cover\r\n    if row['cloudcover'] > 60:  # Slight adjustment\r\n        score += 2  # Medium impact\r\n\r\n    # Wind Speed\r\n    if row['windspeed'] < 7:  # Adjusted for typical UK winds\r\n        score += 2  # Medium impact\r\n\r\n    # Solar Radiation\r\n    if row['solarradiation'] < 150:  # Slight adjustment for UK\r\n        score += 1  # Medium impact\r\n\r\n    # Snow\r\n    if row['snow'] > 0:\r\n        score += 3  # High impact\r\n\r\n    # Visibility\r\n    if row['visibility'] < 5:\r\n        score += 1  # Low impact\r\n\r\n    # UV Index\r\n    if row['uvindex'] < 3:  # Adjusted for typical UK UV levels\r\n        score += 1  # Medium impact\r\n\r\n    # Decision based on score\r\n    if score < 8 and \"Rain\" not in row['conditions']:  # Adjusted threshold\r\n        return \"It's fine to wash clothes today.\"\r\n    else:\r\n        return \"Don't wash clothes today.\"\r\n\r\n@app.route('/weather', methods=['GET'])\r\ndef get_weather_advice():\r\n    try:\r\n        # Fetch the city name from the geolocation API\r\n        city_name = get_location()\r\n        if not city_name:\r\n            raise Exception(\"City name could not be determined.\")\r\n\r\n        # Fetch the weather data for the city\r\n        weather_data = fetch_weather_data(city_name)\r\n        daily_weather = weather_data['days']\r\n\r\n        # Create DataFrame from the data\r\n        df = pd.DataFrame(daily_weather)\r\n\r\n        # Filter data to only include a 7-day window\r\n        current_date = datetime.now().date()\r\n        df['datetime'] = pd.to_datetime(df['datetime']).dt.date\r\n        df = df[df['datetime'] <= current_date + timedelta(days=7)]\r\n\r\n        # Apply the washing advice function and filter for \"It's fine to wash clothes today\"\r\n        df['washing_advice'] = df.apply(should_wash_clothes, axis=1)\r\n        df_filtered = df[df['washing_advice'] == \"It's fine to wash clothes today.\"]\r\n\r\n        # Check if there's a suitable best day\r\n        if len(df_filtered) == 0:\r\n            # No best day found, send today's data instead\r\n            today_data = df[df['datetime'] == current_date].iloc[0] if len(df[df['datetime'] == current_date]) > 0 else None\r\n            \r\n            if today_data is not None:\r\n                best_day_list = [\r\n                    today_data['conditions'],        # Today's condition\r\n                    \"No\",                            # Recommendation\r\n                    \"Nil\",                             # Best day placeholder\r\n                    float(today_data['temp']),      # Today's temperature\r\n                    \"Nil\",                             # Upcoming day placeholder\r\n                    float(today_data['windspeed'])   # Today's wind speed\r\n                ]\r\n            else:\r\n                best_day_list = [\"0\", \"No\", \"0\", 0.0, \"0\", 0.0]  # Fallback if today's data is also missing\r\n\r\n            # Send the best_day_list to InfluxDB\r\n            point = influxdb_client.Point(\"WeatherData\")\\\r\n                .field(\"condition\", best_day_list[0])\\\r\n                .field(\"wash_recommendation\", best_day_list[1])\\\r\n                .field(\"best_day\", best_day_list[2])\\\r\n                .field(\"temperature\", best_day_list[3])\\\r\n                .field(\"upcoming_day\", best_day_list[4])\\\r\n                .field(\"windspeed\", best_day_list[5])\r\n\r\n            # Write point to InfluxDB\r\n            write_api.write(bucket=bucket, org=org, record=point)\r\n\r\n\r\n        else:\r\n            # Collect required information (datetime, windspeed, conditions)\r\n            filtered_data = df_filtered[['datetime', 'temp', 'windspeed', 'conditions']].copy()\r\n\r\n            # Replace \"Clear\" with \"Sunny\" for best day conditions using .loc\r\n            filtered_data.loc[filtered_data['conditions'] == \"Clear\", 'conditions'] = \"Sunny\"\r\n\r\n            # Get the best day and an upcoming day\r\n            best_day_data = filtered_data.iloc[0]  # The best day\r\n            best_day = best_day_data['datetime'].strftime(\"%d/%m/%Y\")\r\n            upcoming_day_data = df[df['datetime'] > best_day_data['datetime']].iloc[0] if len(df[df['datetime'] > best_day_data['datetime']]) > 0 else None\r\n\r\n            if upcoming_day_data is not None:\r\n                upcoming_day = upcoming_day_data['datetime'].strftime(\"%d/%m/%Y\")\r\n                windspeed_upcoming = float(upcoming_day_data['windspeed'])\r\n            else:\r\n                upcoming_day = \"0\"\r\n                windspeed_upcoming = 0.0\r\n\r\n            best_day_list = [\r\n                best_day_data['conditions'],       # \"Sunny\" (replaced Clear)\r\n                \"Yes\",                             # Yes, it's good to wash clothes\r\n                best_day,                          # Best day (e.g., \"22/09/2024\")\r\n                float(best_day_data['temp']),     # Temperature on the best day\r\n                upcoming_day,                      # Upcoming day (e.g., \"23/09/2024\") or \"0\"\r\n                float(best_day_data['windspeed'])  # Wind speed on the best day\r\n            ]\r\n\r\n            # Send the full best_day_list to InfluxDB\r\n            point = influxdb_client.Point(\"WeatherData\")\\\r\n                .field(\"condition\", best_day_list[0])\\\r\n                .field(\"wash_recommendation\", best_day_list[1])\\\r\n                .field(\"best_day\", best_day_list[2])\\\r\n                .field(\"temperature\", best_day_list[3])\\\r\n                .field(\"upcoming_day\", best_day_list[4])\\\r\n                .field(\"windspeed\", best_day_list[5])\r\n\r\n            # Write point to InfluxDB\r\n            write_api.write(bucket=bucket, org=org, record=point)\r\n\r\n        # Return the list in horizontal format as requested\r\n        return jsonify(best_day_list)\r\n\r\n    except Exception as e:\r\n        return jsonify({\"error\": str(e)}), 500\r\n\r\n\r\nif __name__ == '__main__':\r\n    app.run(debug=True)\r\n",
    "roadmap": {
      "next_problem": "LeetCode #15 - Three Sum",
      "concepts_to_learn": [
        "Advanced Hash Map Usage",
        "Time-Space Optimization"
      ],
      "resources": [
        {
          "type": "video",
          "title": "NeetCode - Hash Maps",
          "link": "https://youtu.be/0ZDYRxBvcm8"
        },
        {
          "type": "article",
          "title": "Hash Table Deep Dive",
          "link": "https://www.geeksforgeeks.org/hashing-data-structure/"
        }
      ],
      "weekly_goal": "Master hash map patterns in 4 problems over 3 days"
    }
  },
  {
    "code": "from flask import Flask, jsonify\r\nimport requests\r\nimport pandas as pd\r\nfrom datetime import datetime, timedelta\r\nimport influxdb_client\r\nfrom influxdb_client.client.write_api import SYNCHRONOUS\r\n\r\napp = Flask(__name__)\r\n\r\n# API keys and URLs\r\nweather_api_key = \"CY7T7E66YYDD9CE6BAP5JB9BX\"\r\ngeolocation_api_key = \"5d1f894d5b804ff99f0d5c59a62b1875\"\r\ngeolocation_api_url = f\"https://api.ipgeolocation.io/ipgeo?apiKey={geolocation_api_key}\"\r\n\r\n# InfluxDB configuration\r\nbucket = \"Smart_Home_Energy_managment_System\"\r\norg = \"a2eaff1ac168a82f\"\r\ntoken = \"Skuusy-q0tX5VGiMXFGdprkTRnvV_0z4qBcSw292kd9061RplbL3JvYF4yObaTOuEkMRjemPFPzc-vw3xWGVdg==\"\r\nurl = \"https://us-east-1-1.aws.cloud2.influxdata.com\"\r\n\r\n# Initialize InfluxDB client\r\nclient = influxdb_client.InfluxDBClient(\r\n    url=url,\r\n    token=token,\r\n    org=org\r\n)\r\n\r\n# Write API\r\nwrite_api = client.write_api(write_options=SYNCHRONOUS)\r\n\r\ndef get_location():\r\n    response = requests.get(geolocation_api_url)\r\n    if response.status_code == 200:\r\n        data = response.json()\r\n        city_name = data.get('city', '')  # Extract the city name\r\n        return city_name\r\n    else:\r\n        raise Exception(f\"Error fetching location: {response.status_code}\")\r\n\r\ndef fetch_weather_data(city_name):\r\n    city_name='Kanpur'\r\n    weather_url = f\"https://weather.visualcrossing.com/VisualCrossingWebServices/rest/services/timeline/{city_name}?unitGroup=metric&include=days&key={weather_api_key}&contentType=json\"\r\n    response = requests.get(weather_url)\r\n    if response.status_code == 200:\r\n        return response.json()\r\n    else:\r\n        raise Exception(f\"Error fetching weather data: {response.status_code}\")\r\n\r\ndef should_wash_clothes(row):\r\n    score = 0\r\n\r\n    # Precipitation Probability\r\n    if row['precipprob'] > 30:  # Adjusted for UK conditions\r\n        score += 3  # High impact\r\n\r\n    # Humidity\r\n    if row['humidity'] > 75:  # Adjusted threshold\r\n        score += 3  # High impact\r\n\r\n    # Temperature\r\n    if row['temp'] < 10:  # Adjusted for UK climate\r\n        score += 2  # Medium impact\r\n    if row['temp'] > 25:  # Adjusted upper threshold\r\n        score += 1  # High impact\r\n\r\n    # Dew Point\r\n    if row['dew'] > 15:  # Adjusted threshold\r\n        score += 2  # Medium impact\r\n\r\n    # Cloud Cover\r\n    if row['cloudcover'] > 60:  # Slight adjustment\r\n        score += 2  # Medium impact\r\n\r\n    # Wind Speed\r\n    if row['windspeed'] < 7:  # Adjusted for typical UK winds\r\n        score += 2  # Medium impact\r\n\r\n    # Solar Radiation\r\n    if row['solarradiation'] < 150:  # Slight adjustment for UK\r\n        score += 1  # Medium impact\r\n\r\n    # Snow\r\n    if row['snow'] > 0:\r\n        score += 3  # High impact\r\n\r\n    # Visibility\r\n    if row['visibility'] < 5:\r\n        score += 1  # Low impact\r\n\r\n    # UV Index\r\n    if row['uvindex'] < 3:  # Adjusted for typical UK UV levels\r\n        score += 1  # Medium impact\r\n\r\n    # Decision based on score\r\n    if score < 8 and \"Rain\" not in row['conditions']:  # Adjusted threshold\r\n        return \"It's fine to wash clothes today.\"\r\n    else:\r\n        return \"Don't wash clothes today.\"\r\n\r\n@app.route('/weather', methods=['GET'])\r\ndef get_weather_advice():\r\n    try:\r\n        # Fetch the city name from the geolocation API\r\n        city_name = get_location()\r\n        if not city_name:\r\n            raise Exception(\"City name could not be determined.\")\r\n\r\n        # Fetch the weather data for the city\r\n        weather_data = fetch_weather_data(city_name)\r\n        daily_weather = weather_data['days']\r\n\r\n        # Create DataFrame from the data\r\n        df = pd.DataFrame(daily_weather)\r\n\r\n        # Filter data to only include a 7-day window\r\n        current_date = datetime.now().date()\r\n        df['datetime'] = pd.to_datetime(df['datetime']).dt.date\r\n        df = df[df['datetime'] <= current_date + timedelta(days=7)]\r\n\r\n        # Apply the washing advice function and filter for \"It's fine to wash clothes today\"\r\n        df['washing_advice'] = df.apply(should_wash_clothes, axis=1)\r\n        df_filtered = df[df['washing_advice'] == \"It's fine to wash clothes today.\"]\r\n\r\n        # Check if there's a suitable best day\r\n        if len(df_filtered) == 0:\r\n            # No best day found, send today's data instead\r\n            today_data = df[df['datetime'] == current_date].iloc[0] if len(df[df['datetime'] == current_date]) > 0 else None\r\n            \r\n            if today_data is not None:\r\n                best_day_list = [\r\n                    today_data['conditions'],        # Today's condition\r\n                    \"No\",                            # Recommendation\r\n                    \"Nil\",                             # Best day placeholder\r\n                    float(today_data['temp']),      # Today's temperature\r\n                    \"Nil\",                             # Upcoming day placeholder\r\n                    float(today_data['windspeed'])   # Today's wind speed\r\n                ]\r\n            else:\r\n                best_day_list = [\"0\", \"No\", \"0\", 0.0, \"0\", 0.0]  # Fallback if today's data is also missing\r\n\r\n            # Send the best_day_list to InfluxDB\r\n            point = influxdb_client.Point(\"WeatherData\")\\\r\n                .field(\"condition\", best_day_list[0])\\\r\n                .field(\"wash_recommendation\", best_day_list[1])\\\r\n                .field(\"best_day\", best_day_list[2])\\\r\n                .field(\"temperature\", best_day_list[3])\\\r\n                .field(\"upcoming_day\", best_day_list[4])\\\r\n                .field(\"windspeed\", best_day_list[5])\r\n\r\n            # Write point to InfluxDB\r\n            write_api.write(bucket=bucket, org=org, record=point)\r\n\r\n\r\n        else:\r\n            # Collect required information (datetime, windspeed, conditions)\r\n            filtered_data = df_filtered[['datetime', 'temp', 'windspeed', 'conditions']].copy()\r\n\r\n            # Replace \"Clear\" with \"Sunny\" for best day conditions using .loc\r\n            filtered_data.loc[filtered_data['conditions'] == \"Clear\", 'conditions'] = \"Sunny\"\r\n\r\n            # Get the best day and an upcoming day\r\n            best_day_data = filtered_data.iloc[0]  # The best day\r\n            best_day = best_day_data['datetime'].strftime(\"%d/%m/%Y\")\r\n            upcoming_day_data = df[df['datetime'] > best_day_data['datetime']].iloc[0] if len(df[df['datetime'] > best_day_data['datetime']]) > 0 else None\r\n\r\n            if upcoming_day_data is not None:\r\n                upcoming_day = upcoming_day_data['datetime'].strftime(\"%d/%m/%Y\")\r\n                windspeed_upcoming = float(upcoming_day_data['windspeed'])\r\n            else:\r\n                upcoming_day = \"0\"\r\n                windspeed_upcoming = 0.0\r\n\r\n            best_day_list = [\r\n                best_day_data['conditions'],       # \"Sunny\" (replaced Clear)\r\n                \"Yes\",                             # Yes, it's good to wash clothes\r\n                best_day,                          # Best day (e.g., \"22/09/2024\")\r\n                float(best_day_data['temp']),     # Temperature on the best day\r\n                upcoming_day,                      # Upcoming day (e.g., \"23/09/2024\") or \"0\"\r\n                float(best_day_data['windspeed'])  # Wind speed on the best day\r\n            ]\r\n\r\n            # Send the full best_day_list to InfluxDB\r\n            point = influxdb_client.Point(\"WeatherData\")\\\r\n                .field(\"condition\", best_day_list[0])\\\r\n                .field(\"wash_recommendation\", best_day_list[1])\\\r\n                .field(\"best_day\", best_day_list[2])\\\r\n                .field(\"temperature\", best_day_list[3])\\\r\n                .field(\"upcoming_day\", best_day_list[4])\\\r\n                .field(\"windspeed\", best_day_list[5])\r\n\r\n            # Write point to InfluxDB\r\n            write_api.write(bucket=bucket, org=org, record=point)\r\n\r\n        # Return the list in horizontal format as requested\r\n        return jsonify(best_day_list)\r\n\r\n    except Exception as e:\r\n        return jsonify({\"error\": str(e)}), 500\r\n\r\n\r\nif __name__ == '__main__':\r\n    app.run(debug=True)\r\n",
    "roadmap": {
      "next_problem": "LeetCode #15 - Three Sum",
      "concepts_to_learn": [
        "Advanced Hash Map Usage",
        "Time-Space Optimization"
      ],
      "resources": [
        {
          "type": "video",
          "title": "NeetCode - Hash Maps",
          "link": "https://youtu.be/0ZDYRxBvcm8"
        },
        {
          "type": "article",
          "title": "Hash Table Deep Dive",
          "link": "https://www.geeksforgeeks.org/hashing-data-structure/"
        }
      ],
      "weekly_goal": "Master hash map patterns in 4 problems over 3 days"
    }
  },
  {
    "code": "from flask import Flask, jsonify\r\nimport requests\r\nimport pandas as pd\r\nfrom datetime import datetime, timedelta\r\nimport influxdb_client\r\nfrom influxdb_client.client.write_api import SYNCHRONOUS\r\n\r\napp = Flask(__name__)\r\n\r\n# API keys and URLs\r\nweather_api_key = \"CY7T7E66YYDD9CE6BAP5JB9BX\"\r\ngeolocation_api_key = \"5d1f894d5b804ff99f0d5c59a62b1875\"\r\ngeolocation_api_url = f\"https://api.ipgeolocation.io/ipgeo?apiKey={geolocation_api_key}\"\r\n\r\n# InfluxDB configuration\r\nbucket = \"Smart_Home_Energy_managment_System\"\r\norg = \"a2eaff1ac168a82f\"\r\ntoken = \"Skuusy-q0tX5VGiMXFGdprkTRnvV_0z4qBcSw292kd9061RplbL3JvYF4yObaTOuEkMRjemPFPzc-vw3xWGVdg==\"\r\nurl = \"https://us-east-1-1.aws.cloud2.influxdata.com\"\r\n\r\n# Initialize InfluxDB client\r\nclient = influxdb_client.InfluxDBClient(\r\n    url=url,\r\n    token=token,\r\n    org=org\r\n)\r\n\r\n# Write API\r\nwrite_api = client.write_api(write_options=SYNCHRONOUS)\r\n\r\ndef get_location():\r\n    response = requests.get(geolocation_api_url)\r\n    if response.status_code == 200:\r\n        data = response.json()\r\n        city_name = data.get('city', '')  # Extract the city name\r\n        return city_name\r\n    else:\r\n        raise Exception(f\"Error fetching location: {response.status_code}\")\r\n\r\ndef fetch_weather_data(city_name):\r\n    city_name='Kanpur'\r\n    weather_url = f\"https://weather.visualcrossing.com/VisualCrossingWebServices/rest/services/timeline/{city_name}?unitGroup=metric&include=days&key={weather_api_key}&contentType=json\"\r\n    response = requests.get(weather_url)\r\n    if response.status_code == 200:\r\n        return response.json()\r\n    else:\r\n        raise Exception(f\"Error fetching weather data: {response.status_code}\")\r\n\r\ndef should_wash_clothes(row):\r\n    score = 0\r\n\r\n    # Precipitation Probability\r\n    if row['precipprob'] > 30:  # Adjusted for UK conditions\r\n        score += 3  # High impact\r\n\r\n    # Humidity\r\n    if row['humidity'] > 75:  # Adjusted threshold\r\n        score += 3  # High impact\r\n\r\n    # Temperature\r\n    if row['temp'] < 10:  # Adjusted for UK climate\r\n        score += 2  # Medium impact\r\n    if row['temp'] > 25:  # Adjusted upper threshold\r\n        score += 1  # High impact\r\n\r\n    # Dew Point\r\n    if row['dew'] > 15:  # Adjusted threshold\r\n        score += 2  # Medium impact\r\n\r\n    # Cloud Cover\r\n    if row['cloudcover'] > 60:  # Slight adjustment\r\n        score += 2  # Medium impact\r\n\r\n    # Wind Speed\r\n    if row['windspeed'] < 7:  # Adjusted for typical UK winds\r\n        score += 2  # Medium impact\r\n\r\n    # Solar Radiation\r\n    if row['solarradiation'] < 150:  # Slight adjustment for UK\r\n        score += 1  # Medium impact\r\n\r\n    # Snow\r\n    if row['snow'] > 0:\r\n        score += 3  # High impact\r\n\r\n    # Visibility\r\n    if row['visibility'] < 5:\r\n        score += 1  # Low impact\r\n\r\n    # UV Index\r\n    if row['uvindex'] < 3:  # Adjusted for typical UK UV levels\r\n        score += 1  # Medium impact\r\n\r\n    # Decision based on score\r\n    if score < 8 and \"Rain\" not in row['conditions']:  # Adjusted threshold\r\n        return \"It's fine to wash clothes today.\"\r\n    else:\r\n        return \"Don't wash clothes today.\"\r\n\r\n@app.route('/weather', methods=['GET'])\r\ndef get_weather_advice():\r\n    try:\r\n        # Fetch the city name from the geolocation API\r\n        city_name = get_location()\r\n        if not city_name:\r\n            raise Exception(\"City name could not be determined.\")\r\n\r\n        # Fetch the weather data for the city\r\n        weather_data = fetch_weather_data(city_name)\r\n        daily_weather = weather_data['days']\r\n\r\n        # Create DataFrame from the data\r\n        df = pd.DataFrame(daily_weather)\r\n\r\n        # Filter data to only include a 7-day window\r\n        current_date = datetime.now().date()\r\n        df['datetime'] = pd.to_datetime(df['datetime']).dt.date\r\n        df = df[df['datetime'] <= current_date + timedelta(days=7)]\r\n\r\n        # Apply the washing advice function and filter for \"It's fine to wash clothes today\"\r\n        df['washing_advice'] = df.apply(should_wash_clothes, axis=1)\r\n        df_filtered = df[df['washing_advice'] == \"It's fine to wash clothes today.\"]\r\n\r\n        # Check if there's a suitable best day\r\n        if len(df_filtered) == 0:\r\n            # No best day found, send today's data instead\r\n            today_data = df[df['datetime'] == current_date].iloc[0] if len(df[df['datetime'] == current_date]) > 0 else None\r\n            \r\n            if today_data is not None:\r\n                best_day_list = [\r\n                    today_data['conditions'],        # Today's condition\r\n                    \"No\",                            # Recommendation\r\n                    \"Nil\",                             # Best day placeholder\r\n                    float(today_data['temp']),      # Today's temperature\r\n                    \"Nil\",                             # Upcoming day placeholder\r\n                    float(today_data['windspeed'])   # Today's wind speed\r\n                ]\r\n            else:\r\n                best_day_list = [\"0\", \"No\", \"0\", 0.0, \"0\", 0.0]  # Fallback if today's data is also missing\r\n\r\n            # Send the best_day_list to InfluxDB\r\n            point = influxdb_client.Point(\"WeatherData\")\\\r\n                .field(\"condition\", best_day_list[0])\\\r\n                .field(\"wash_recommendation\", best_day_list[1])\\\r\n                .field(\"best_day\", best_day_list[2])\\\r\n                .field(\"temperature\", best_day_list[3])\\\r\n                .field(\"upcoming_day\", best_day_list[4])\\\r\n                .field(\"windspeed\", best_day_list[5])\r\n\r\n            # Write point to InfluxDB\r\n            write_api.write(bucket=bucket, org=org, record=point)\r\n\r\n\r\n        else:\r\n            # Collect required information (datetime, windspeed, conditions)\r\n            filtered_data = df_filtered[['datetime', 'temp', 'windspeed', 'conditions']].copy()\r\n\r\n            # Replace \"Clear\" with \"Sunny\" for best day conditions using .loc\r\n            filtered_data.loc[filtered_data['conditions'] == \"Clear\", 'conditions'] = \"Sunny\"\r\n\r\n            # Get the best day and an upcoming day\r\n            best_day_data = filtered_data.iloc[0]  # The best day\r\n            best_day = best_day_data['datetime'].strftime(\"%d/%m/%Y\")\r\n            upcoming_day_data = df[df['datetime'] > best_day_data['datetime']].iloc[0] if len(df[df['datetime'] > best_day_data['datetime']]) > 0 else None\r\n\r\n            if upcoming_day_data is not None:\r\n                upcoming_day = upcoming_day_data['datetime'].strftime(\"%d/%m/%Y\")\r\n                windspeed_upcoming = float(upcoming_day_data['windspeed'])\r\n            else:\r\n                upcoming_day = \"0\"\r\n                windspeed_upcoming = 0.0\r\n\r\n            best_day_list = [\r\n                best_day_data['conditions'],       # \"Sunny\" (replaced Clear)\r\n                \"Yes\",                             # Yes, it's good to wash clothes\r\n                best_day,                          # Best day (e.g., \"22/09/2024\")\r\n                float(best_day_data['temp']),     # Temperature on the best day\r\n                upcoming_day,                      # Upcoming day (e.g., \"23/09/2024\") or \"0\"\r\n                float(best_day_data['windspeed'])  # Wind speed on the best day\r\n            ]\r\n\r\n            # Send the full best_day_list to InfluxDB\r\n            point = influxdb_client.Point(\"WeatherData\")\\\r\n                .field(\"condition\", best_day_list[0])\\\r\n                .field(\"wash_recommendation\", best_day_list[1])\\\r\n                .field(\"best_day\", best_day_list[2])\\\r\n                .field(\"temperature\", best_day_list[3])\\\r\n                .field(\"upcoming_day\", best_day_list[4])\\\r\n                .field(\"windspeed\", best_day_list[5])\r\n\r\n            # Write point to InfluxDB\r\n            write_api.write(bucket=bucket, org=org, record=point)\r\n\r\n        # Return the list in horizontal format as requested\r\n        return jsonify(best_day_list)\r\n\r\n    except Exception as e:\r\n        return jsonify({\"error\": str(e)}), 500\r\n\r\n\r\nif __name__ == '__main__':\r\n    app.run(debug=True)\r\n",
    "roadmap": {
      "next_problem": "LeetCode #15 - Three Sum",
      "concepts_to_learn": [
        "Advanced Hash Map Usage",
        "Time-Space Optimization"
      ],
      "resources": [
        {
          "type": "video",
          "title": "NeetCode - Hash Maps",
          "link": "https://youtu.be/0ZDYRxBvcm8"
        },
        {
          "type": "article",
          "title": "Hash Table Deep Dive",
          "link": "https://www.geeksforgeeks.org/hashing-data-structure/"
        }
      ],
      "weekly_goal": "Master hash map patterns in 4 problems over 3 days"
    }
  },
  {
    "code": "from flask import Flask, jsonify\r\nimport requests\r\nimport pandas as pd\r\nfrom datetime import datetime, timedelta\r\nimport influxdb_client\r\nfrom influxdb_client.client.write_api import SYNCHRONOUS\r\n\r\napp = Flask(__name__)\r\n\r\n# API keys and URLs\r\nweather_api_key = \"CY7T7E66YYDD9CE6BAP5JB9BX\"\r\ngeolocation_api_key = \"5d1f894d5b804ff99f0d5c59a62b1875\"\r\ngeolocation_api_url = f\"https://api.ipgeolocation.io/ipgeo?apiKey={geolocation_api_key}\"\r\n\r\n# InfluxDB configuration\r\nbucket = \"Smart_Home_Energy_managment_System\"\r\norg = \"a2eaff1ac168a82f\"\r\ntoken = \"Skuusy-q0tX5VGiMXFGdprkTRnvV_0z4qBcSw292kd9061RplbL3JvYF4yObaTOuEkMRjemPFPzc-vw3xWGVdg==\"\r\nurl = \"https://us-east-1-1.aws.cloud2.influxdata.com\"\r\n\r\n# Initialize InfluxDB client\r\nclient = influxdb_client.InfluxDBClient(\r\n    url=url,\r\n    token=token,\r\n    org=org\r\n)\r\n\r\n# Write API\r\nwrite_api = client.write_api(write_options=SYNCHRONOUS)\r\n\r\ndef get_location():\r\n    response = requests.get(geolocation_api_url)\r\n    if response.status_code == 200:\r\n        data = response.json()\r\n        city_name = data.get('city', '')  # Extract the city name\r\n        return city_name\r\n    else:\r\n        raise Exception(f\"Error fetching location: {response.status_code}\")\r\n\r\ndef fetch_weather_data(city_name):\r\n    city_name='Kanpur'\r\n    weather_url = f\"https://weather.visualcrossing.com/VisualCrossingWebServices/rest/services/timeline/{city_name}?unitGroup=metric&include=days&key={weather_api_key}&contentType=json\"\r\n    response = requests.get(weather_url)\r\n    if response.status_code == 200:\r\n        return response.json()\r\n    else:\r\n        raise Exception(f\"Error fetching weather data: {response.status_code}\")\r\n\r\ndef should_wash_clothes(row):\r\n    score = 0\r\n\r\n    # Precipitation Probability\r\n    if row['precipprob'] > 30:  # Adjusted for UK conditions\r\n        score += 3  # High impact\r\n\r\n    # Humidity\r\n    if row['humidity'] > 75:  # Adjusted threshold\r\n        score += 3  # High impact\r\n\r\n    # Temperature\r\n    if row['temp'] < 10:  # Adjusted for UK climate\r\n        score += 2  # Medium impact\r\n    if row['temp'] > 25:  # Adjusted upper threshold\r\n        score += 1  # High impact\r\n\r\n    # Dew Point\r\n    if row['dew'] > 15:  # Adjusted threshold\r\n        score += 2  # Medium impact\r\n\r\n    # Cloud Cover\r\n    if row['cloudcover'] > 60:  # Slight adjustment\r\n        score += 2  # Medium impact\r\n\r\n    # Wind Speed\r\n    if row['windspeed'] < 7:  # Adjusted for typical UK winds\r\n        score += 2  # Medium impact\r\n\r\n    # Solar Radiation\r\n    if row['solarradiation'] < 150:  # Slight adjustment for UK\r\n        score += 1  # Medium impact\r\n\r\n    # Snow\r\n    if row['snow'] > 0:\r\n        score += 3  # High impact\r\n\r\n    # Visibility\r\n    if row['visibility'] < 5:\r\n        score += 1  # Low impact\r\n\r\n    # UV Index\r\n    if row['uvindex'] < 3:  # Adjusted for typical UK UV levels\r\n        score += 1  # Medium impact\r\n\r\n    # Decision based on score\r\n    if score < 8 and \"Rain\" not in row['conditions']:  # Adjusted threshold\r\n        return \"It's fine to wash clothes today.\"\r\n    else:\r\n        return \"Don't wash clothes today.\"\r\n\r\n@app.route('/weather', methods=['GET'])\r\ndef get_weather_advice():\r\n    try:\r\n        # Fetch the city name from the geolocation API\r\n        city_name = get_location()\r\n        if not city_name:\r\n            raise Exception(\"City name could not be determined.\")\r\n\r\n        # Fetch the weather data for the city\r\n        weather_data = fetch_weather_data(city_name)\r\n        daily_weather = weather_data['days']\r\n\r\n        # Create DataFrame from the data\r\n        df = pd.DataFrame(daily_weather)\r\n\r\n        # Filter data to only include a 7-day window\r\n        current_date = datetime.now().date()\r\n        df['datetime'] = pd.to_datetime(df['datetime']).dt.date\r\n        df = df[df['datetime'] <= current_date + timedelta(days=7)]\r\n\r\n        # Apply the washing advice function and filter for \"It's fine to wash clothes today\"\r\n        df['washing_advice'] = df.apply(should_wash_clothes, axis=1)\r\n        df_filtered = df[df['washing_advice'] == \"It's fine to wash clothes today.\"]\r\n\r\n        # Check if there's a suitable best day\r\n        if len(df_filtered) == 0:\r\n            # No best day found, send today's data instead\r\n            today_data = df[df['datetime'] == current_date].iloc[0] if len(df[df['datetime'] == current_date]) > 0 else None\r\n            \r\n            if today_data is not None:\r\n                best_day_list = [\r\n                    today_data['conditions'],        # Today's condition\r\n                    \"No\",                            # Recommendation\r\n                    \"Nil\",                             # Best day placeholder\r\n                    float(today_data['temp']),      # Today's temperature\r\n                    \"Nil\",                             # Upcoming day placeholder\r\n                    float(today_data['windspeed'])   # Today's wind speed\r\n                ]\r\n            else:\r\n                best_day_list = [\"0\", \"No\", \"0\", 0.0, \"0\", 0.0]  # Fallback if today's data is also missing\r\n\r\n            # Send the best_day_list to InfluxDB\r\n            point = influxdb_client.Point(\"WeatherData\")\\\r\n                .field(\"condition\", best_day_list[0])\\\r\n                .field(\"wash_recommendation\", best_day_list[1])\\\r\n                .field(\"best_day\", best_day_list[2])\\\r\n                .field(\"temperature\", best_day_list[3])\\\r\n                .field(\"upcoming_day\", best_day_list[4])\\\r\n                .field(\"windspeed\", best_day_list[5])\r\n\r\n            # Write point to InfluxDB\r\n            write_api.write(bucket=bucket, org=org, record=point)\r\n\r\n\r\n        else:\r\n            # Collect required information (datetime, windspeed, conditions)\r\n            filtered_data = df_filtered[['datetime', 'temp', 'windspeed', 'conditions']].copy()\r\n\r\n            # Replace \"Clear\" with \"Sunny\" for best day conditions using .loc\r\n            filtered_data.loc[filtered_data['conditions'] == \"Clear\", 'conditions'] = \"Sunny\"\r\n\r\n            # Get the best day and an upcoming day\r\n            best_day_data = filtered_data.iloc[0]  # The best day\r\n            best_day = best_day_data['datetime'].strftime(\"%d/%m/%Y\")\r\n            upcoming_day_data = df[df['datetime'] > best_day_data['datetime']].iloc[0] if len(df[df['datetime'] > best_day_data['datetime']]) > 0 else None\r\n\r\n            if upcoming_day_data is not None:\r\n                upcoming_day = upcoming_day_data['datetime'].strftime(\"%d/%m/%Y\")\r\n                windspeed_upcoming = float(upcoming_day_data['windspeed'])\r\n            else:\r\n                upcoming_day = \"0\"\r\n                windspeed_upcoming = 0.0\r\n\r\n            best_day_list = [\r\n                best_day_data['conditions'],       # \"Sunny\" (replaced Clear)\r\n                \"Yes\",                             # Yes, it's good to wash clothes\r\n                best_day,                          # Best day (e.g., \"22/09/2024\")\r\n                float(best_day_data['temp']),     # Temperature on the best day\r\n                upcoming_day,                      # Upcoming day (e.g., \"23/09/2024\") or \"0\"\r\n                float(best_day_data['windspeed'])  # Wind speed on the best day\r\n            ]\r\n\r\n            # Send the full best_day_list to InfluxDB\r\n            point = influxdb_client.Point(\"WeatherData\")\\\r\n                .field(\"condition\", best_day_list[0])\\\r\n                .field(\"wash_recommendation\", best_day_list[1])\\\r\n                .field(\"best_day\", best_day_list[2])\\\r\n                .field(\"temperature\", best_day_list[3])\\\r\n                .field(\"upcoming_day\", best_day_list[4])\\\r\n                .field(\"windspeed\", best_day_list[5])\r\n\r\n            # Write point to InfluxDB\r\n            write_api.write(bucket=bucket, org=org, record=point)\r\n\r\n        # Return the list in horizontal format as requested\r\n        return jsonify(best_day_list)\r\n\r\n    except Exception as e:\r\n        return jsonify({\"error\": str(e)}), 500\r\n\r\n\r\nif __name__ == '__main__':\r\n    app.run(debug=True)\r\n",
    "roadmap": {
      "next_problem": "LeetCode #15 - Three Sum",
      "concepts_to_learn": [
        "Advanced Hash Map Usage",
        "Time-Space Optimization"
      ],
      "resources": [
        {
          "type": "video",
          "title": "NeetCode - Hash Maps",
          "link": "https://youtu.be/0ZDYRxBvcm8"
        },
        {
          "type": "article",
          "title": "Hash Table Deep Dive",
          "link": "https://www.geeksforgeeks.org/hashing-data-structure/"
        }
      ],
      "weekly_goal": "Master hash map patterns in 4 problems over 3 days"
    }
  },
  {
    "code": "import streamlit as st\r\nimport pandas as pd\r\nimport pickle\r\n\r\n# Load pre-trained model\r\nmodel_path = \"C:/Users/YERNI KUMAR/Downloads/forecasting/xgb_model.pkl\"\r\nwith open(model_path, \"rb\") as file:\r\n    model = pickle.load(file)\r\n\r\n# Function to encode user inputs based on the model's feature expectations\r\ndef encode_user_input(input_df, model):\r\n    # Perform necessary encoding for categorical variables as done during model training\r\n    input_encoded = pd.get_dummies(input_df)\r\n    \r\n    # Align with the columns used during training\r\n    input_encoded = input_encoded.reindex(columns=model.feature_names_in_, fill_value=0)\r\n    \r\n    return input_encoded\r\n\r\n# Function to collect user inputs\r\ndef user_input_features():\r\n    st.sidebar.header(\"User Input Features\")\r\n\r\n    # Center the input form using columns to manage layout\r\n    col1, col2, col3 = st.columns([1, 2, 1])  # Make the center column wider\r\n\r\n    with col2:\r\n        st.subheader(\"Resale Price Prediction\")\r\n\r\n        # Collect user inputs for all features in the center column\r\n        town = st.selectbox(\"Town\", options=['Town A', 'Town B', 'Town C'])\r\n        flat_type = st.selectbox(\"Flat Type\", options=['Type A', 'Type B', 'Type C'])\r\n        block = st.text_input(\"Block\")\r\n        street_name = st.text_input(\"Street Name\")\r\n        storey_range = st.selectbox(\"Storey Range\", options=['01 to 03', '04 to 06', '07 to 09'])\r\n        floor_area_sqm = st.number_input(\"Floor Area (sqm)\", min_value=0.0, step=1.0)\r\n        flat_model = st.selectbox(\"Flat Model\", options=['Model A', 'Model B', 'Model C'])\r\n        lease_commence_date = st.number_input(\"Lease Commence Date\", min_value=1900, step=1)\r\n        remaining_lease = st.number_input(\"Remaining Lease\", min_value=0, step=1)\r\n\r\n        # Create a DataFrame from user input\r\n        input_data = {\r\n            'town': town,\r\n            'flat_type': flat_type,\r\n            'block': block,\r\n            'street_name': street_name,\r\n            'storey_range': storey_range,\r\n            'floor_area_sqm': floor_area_sqm,\r\n            'flat_model': flat_model,\r\n            'lease_commence_date': lease_commence_date,\r\n            'remaining_lease': remaining_lease\r\n        }\r\n\r\n        input_df = pd.DataFrame([input_data])\r\n\r\n        # Encode categorical features\r\n        input_encoded = encode_user_input(input_df, model)\r\n\r\n        return input_encoded\r\n\r\n# Prediction function\r\ndef predict_resale_price(input_df):\r\n    # Perform prediction\r\n    prediction = model.predict(input_df.values)\r\n    return prediction\r\n\r\n# Main application\r\ndef main():\r\n    st.title(\"Resale Price Prediction\")\r\n\r\n    # Center the input form and get inputs\r\n    inputs = user_input_features()\r\n\r\n    # Display input data\r\n    st.subheader(\"User Input Data\")\r\n    st.write(inputs)\r\n\r\n    # Predict resale price\r\n    col1, col2, col3 = st.columns([1, 2, 1])  # Center button and result\r\n    with col2:\r\n        if st.button(\"Predict\"):\r\n            result = predict_resale_price(inputs)\r\n            st.subheader(f\"Predicted Resale Price: ${result[0]:,.2f}\")\r\n\r\nif __name__ == \"__main__\":\r\n    main()\r\n",
    "roadmap": {
      "next_problem": "LeetCode #15 - Three Sum",
      "concepts_to_learn": [
        "Advanced Hash Map Usage",
        "Time-Space Optimization"
      ],
      "resources": [
        {
          "type": "video",
          "title": "NeetCode - Hash Maps",
          "link": "https://youtu.be/0ZDYRxBvcm8"
        },
        {
          "type": "article",
          "title": "Hash Table Deep Dive",
          "link": "https://www.geeksforgeeks.org/hashing-data-structure/"
        }
      ],
      "weekly_goal": "Master hash map patterns in 4 problems over 3 days"
    }
  },
  {
    "code": "#influxdb Date and time Write Code\r\n\r\nimport influxdb_client\r\nfrom influxdb_client.client.write_api import SYNCHRONOUS\r\nfrom datetime import datetime\r\n\r\n# Configuration\r\nbucket = \"Esp32\"\r\norg = \"188001aa9267f088\"\r\ntoken = \"7-FtIDytDAxs_zcWNvI_5qe8d3OceCCA_xeAhL4IQvPwGYqY2BEvNHWOV4_5iYlhdXdj6CsvO1ZoJVWB3YSLuA==\"\r\nurl = \"https://us-east-1-1.aws.cloud2.influxdata.com\"\r\n\r\n# Initialize InfluxDB client\r\nclient = influxdb_client.InfluxDBClient(\r\n    url=url,\r\n    token=token,\r\n    org=org\r\n)\r\n\r\n# Write API\r\nwrite_api = client.write_api(write_options=SYNCHRONOUS)\r\n\r\ntemperature = 24.5  # Example temperature value\r\nhumidity = 60.2     # Example humidity value\r\nvoltage = 230.4     # Example voltage value\r\n\r\n# Create a point with current date and time as a string\r\n#current_time = datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\r\ncurrent_time = datetime.now().strftime(\"%Y-%m-%d\")\r\npoint = influxdb_client.Point(\"EnergyMeter\")\\\r\n    .field(\"temperature\", temperature)\r\n\r\n# Write point to InfluxDB\r\nwrite_api.write(bucket=bucket, org=org, record=point)\r\n\r\npoint = influxdb_client.Point(\"EnergyMeter\")\\\r\n    .field(\"humidity\", humidity)\r\n\r\n# Write point to InfluxDB\r\nwrite_api.write(bucket=bucket, org=org, record=point)\r\n\r\npoint = influxdb_client.Point(\"EnergyMeter\")\\\r\n    .field(\"voltage\", voltage)\r\n\r\n# Write point to InfluxDB\r\nwrite_api.write(bucket=bucket, org=org, record=point)\r\n\r\n#print(f\"Written time string: {current_time} to InfluxDB.\")\r\n",
    "roadmap": {
      "next_problem": "LeetCode #15 - Three Sum",
      "concepts_to_learn": [
        "Advanced Hash Map Usage",
        "Time-Space Optimization"
      ],
      "resources": [
        {
          "type": "video",
          "title": "NeetCode - Hash Maps",
          "link": "https://youtu.be/0ZDYRxBvcm8"
        },
        {
          "type": "article",
          "title": "Hash Table Deep Dive",
          "link": "https://www.geeksforgeeks.org/hashing-data-structure/"
        }
      ],
      "weekly_goal": "Master hash map patterns in 4 problems over 3 days"
    }
  },
  {
    "code": "from flask import Flask, jsonify\r\nimport requests\r\nimport pandas as pd\r\nfrom datetime import datetime, timedelta\r\nimport influxdb_client\r\nfrom influxdb_client.client.write_api import SYNCHRONOUS\r\n\r\napp = Flask(__name__)\r\n\r\n# API keys and URLs\r\nweather_api_key = \"CY7T7E66YYDD9CE6BAP5JB9BX\"\r\ngeolocation_api_key = \"5d1f894d5b804ff99f0d5c59a62b1875\"\r\ngeolocation_api_url = f\"https://api.ipgeolocation.io/ipgeo?apiKey={geolocation_api_key}\"\r\n\r\n# InfluxDB configuration\r\nbucket = \"Smart_Home_Energy_managment_System\"\r\norg = \"a2eaff1ac168a82f\"\r\ntoken = \"Skuusy-q0tX5VGiMXFGdprkTRnvV_0z4qBcSw292kd9061RplbL3JvYF4yObaTOuEkMRjemPFPzc-vw3xWGVdg==\"\r\nurl = \"https://us-east-1-1.aws.cloud2.influxdata.com\"\r\n\r\n# Initialize InfluxDB client\r\nclient = influxdb_client.InfluxDBClient(\r\n    url=url,\r\n    token=token,\r\n    org=org\r\n)\r\n\r\n# Write API\r\nwrite_api = client.write_api(write_options=SYNCHRONOUS)\r\n\r\ndef get_location():\r\n    response = requests.get(geolocation_api_url)\r\n    if response.status_code == 200:\r\n        data = response.json()\r\n        city_name = data.get('city', '')  # Extract the city name\r\n        return city_name\r\n    else:\r\n        raise Exception(f\"Error fetching location: {response.status_code}\")\r\n\r\ndef fetch_weather_data(city_name):\r\n    city_name='Kanpur'\r\n    weather_url = f\"https://weather.visualcrossing.com/VisualCrossingWebServices/rest/services/timeline/{city_name}?unitGroup=metric&include=days&key={weather_api_key}&contentType=json\"\r\n    response = requests.get(weather_url)\r\n    if response.status_code == 200:\r\n        return response.json()\r\n    else:\r\n        raise Exception(f\"Error fetching weather data: {response.status_code}\")\r\n\r\ndef should_wash_clothes(row):\r\n    score = 0\r\n\r\n    # Precipitation Probability\r\n    if row['precipprob'] > 30:  # Adjusted for UK conditions\r\n        score += 3  # High impact\r\n\r\n    # Humidity\r\n    if row['humidity'] > 75:  # Adjusted threshold\r\n        score += 3  # High impact\r\n\r\n    # Temperature\r\n    if row['temp'] < 10:  # Adjusted for UK climate\r\n        score += 2  # Medium impact\r\n    if row['temp'] > 25:  # Adjusted upper threshold\r\n        score += 1  # High impact\r\n\r\n    # Dew Point\r\n    if row['dew'] > 15:  # Adjusted threshold\r\n        score += 2  # Medium impact\r\n\r\n    # Cloud Cover\r\n    if row['cloudcover'] > 60:  # Slight adjustment\r\n        score += 2  # Medium impact\r\n\r\n    # Wind Speed\r\n    if row['windspeed'] < 7:  # Adjusted for typical UK winds\r\n        score += 2  # Medium impact\r\n\r\n    # Solar Radiation\r\n    if row['solarradiation'] < 150:  # Slight adjustment for UK\r\n        score += 1  # Medium impact\r\n\r\n    # Snow\r\n    if row['snow'] > 0:\r\n        score += 3  # High impact\r\n\r\n    # Visibility\r\n    if row['visibility'] < 5:\r\n        score += 1  # Low impact\r\n\r\n    # UV Index\r\n    if row['uvindex'] < 3:  # Adjusted for typical UK UV levels\r\n        score += 1  # Medium impact\r\n\r\n    # Decision based on score\r\n    if score < 8 and \"Rain\" not in row['conditions']:  # Adjusted threshold\r\n        return \"It's fine to wash clothes today.\"\r\n    else:\r\n        return \"Don't wash clothes today.\"\r\n\r\n@app.route('/weather', methods=['GET'])\r\ndef get_weather_advice():\r\n    try:\r\n        # Fetch the city name from the geolocation API\r\n        city_name = get_location()\r\n        if not city_name:\r\n            raise Exception(\"City name could not be determined.\")\r\n\r\n        # Fetch the weather data for the city\r\n        weather_data = fetch_weather_data(city_name)\r\n        daily_weather = weather_data['days']\r\n\r\n        # Create DataFrame from the data\r\n        df = pd.DataFrame(daily_weather)\r\n\r\n        # Filter data to only include a 7-day window\r\n        current_date = datetime.now().date()\r\n        df['datetime'] = pd.to_datetime(df['datetime']).dt.date\r\n        df = df[df['datetime'] <= current_date + timedelta(days=7)]\r\n\r\n        # Apply the washing advice function and filter for \"It's fine to wash clothes today\"\r\n        df['washing_advice'] = df.apply(should_wash_clothes, axis=1)\r\n        df_filtered = df[df['washing_advice'] == \"It's fine to wash clothes today.\"]\r\n\r\n        # Check if there's a suitable best day\r\n        if len(df_filtered) == 0:\r\n            # No best day found, send today's data instead\r\n            today_data = df[df['datetime'] == current_date].iloc[0] if len(df[df['datetime'] == current_date]) > 0 else None\r\n            \r\n            if today_data is not None:\r\n                best_day_list = [\r\n                    today_data['conditions'],        # Today's condition\r\n                    \"No\",                            # Recommendation\r\n                    \"Nil\",                             # Best day placeholder\r\n                    float(today_data['temp']),      # Today's temperature\r\n                    \"Nil\",                             # Upcoming day placeholder\r\n                    float(today_data['windspeed'])   # Today's wind speed\r\n                ]\r\n            else:\r\n                best_day_list = [\"0\", \"No\", \"0\", 0.0, \"0\", 0.0]  # Fallback if today's data is also missing\r\n\r\n            # Send the best_day_list to InfluxDB\r\n            point = influxdb_client.Point(\"WeatherData\")\\\r\n                .field(\"condition\", best_day_list[0])\\\r\n                .field(\"wash_recommendation\", best_day_list[1])\\\r\n                .field(\"best_day\", best_day_list[2])\\\r\n                .field(\"temperature\", best_day_list[3])\\\r\n                .field(\"upcoming_day\", best_day_list[4])\\\r\n                .field(\"windspeed\", best_day_list[5])\r\n\r\n            # Write point to InfluxDB\r\n            write_api.write(bucket=bucket, org=org, record=point)\r\n\r\n\r\n        else:\r\n            # Collect required information (datetime, windspeed, conditions)\r\n            filtered_data = df_filtered[['datetime', 'temp', 'windspeed', 'conditions']].copy()\r\n\r\n            # Replace \"Clear\" with \"Sunny\" for best day conditions using .loc\r\n            filtered_data.loc[filtered_data['conditions'] == \"Clear\", 'conditions'] = \"Sunny\"\r\n\r\n            # Get the best day and an upcoming day\r\n            best_day_data = filtered_data.iloc[0]  # The best day\r\n            best_day = best_day_data['datetime'].strftime(\"%d/%m/%Y\")\r\n            upcoming_day_data = df[df['datetime'] > best_day_data['datetime']].iloc[0] if len(df[df['datetime'] > best_day_data['datetime']]) > 0 else None\r\n\r\n            if upcoming_day_data is not None:\r\n                upcoming_day = upcoming_day_data['datetime'].strftime(\"%d/%m/%Y\")\r\n                windspeed_upcoming = float(upcoming_day_data['windspeed'])\r\n            else:\r\n                upcoming_day = \"0\"\r\n                windspeed_upcoming = 0.0\r\n\r\n            best_day_list = [\r\n                best_day_data['conditions'],       # \"Sunny\" (replaced Clear)\r\n                \"Yes\",                             # Yes, it's good to wash clothes\r\n                best_day,                          # Best day (e.g., \"22/09/2024\")\r\n                float(best_day_data['temp']),     # Temperature on the best day\r\n                upcoming_day,                      # Upcoming day (e.g., \"23/09/2024\") or \"0\"\r\n                float(best_day_data['windspeed'])  # Wind speed on the best day\r\n            ]\r\n\r\n            # Send the full best_day_list to InfluxDB\r\n            point = influxdb_client.Point(\"WeatherData\")\\\r\n                .field(\"condition\", best_day_list[0])\\\r\n                .field(\"wash_recommendation\", best_day_list[1])\\\r\n                .field(\"best_day\", best_day_list[2])\\\r\n                .field(\"temperature\", best_day_list[3])\\\r\n                .field(\"upcoming_day\", best_day_list[4])\\\r\n                .field(\"windspeed\", best_day_list[5])\r\n\r\n            # Write point to InfluxDB\r\n            write_api.write(bucket=bucket, org=org, record=point)\r\n\r\n        # Return the list in horizontal format as requested\r\n        return jsonify(best_day_list)\r\n\r\n    except Exception as e:\r\n        return jsonify({\"error\": str(e)}), 500\r\n\r\n\r\nif __name__ == '__main__':\r\n    app.run(debug=True)\r\n",
    "roadmap": {
      "next_problem": "LeetCode #15 - Three Sum",
      "concepts_to_learn": [
        "Advanced Hash Map Usage",
        "Time-Space Optimization"
      ],
      "resources": [
        {
          "type": "video",
          "title": "NeetCode - Hash Maps",
          "link": "https://youtu.be/0ZDYRxBvcm8"
        },
        {
          "type": "article",
          "title": "Hash Table Deep Dive",
          "link": "https://www.geeksforgeeks.org/hashing-data-structure/"
        }
      ],
      "weekly_goal": "Master hash map patterns in 4 problems over 3 days"
    }
  },
  {
    "code": "from flask import Flask, jsonify\r\nimport requests\r\nimport pandas as pd\r\nfrom datetime import datetime, timedelta\r\nimport influxdb_client\r\nfrom influxdb_client.client.write_api import SYNCHRONOUS\r\n\r\napp = Flask(__name__)\r\n\r\n# API keys and URLs\r\nweather_api_key = \"CY7T7E66YYDD9CE6BAP5JB9BX\"\r\ngeolocation_api_key = \"5d1f894d5b804ff99f0d5c59a62b1875\"\r\ngeolocation_api_url = f\"https://api.ipgeolocation.io/ipgeo?apiKey={geolocation_api_key}\"\r\n\r\n# InfluxDB configuration\r\nbucket = \"Smart_Home_Energy_managment_System\"\r\norg = \"a2eaff1ac168a82f\"\r\ntoken = \"Skuusy-q0tX5VGiMXFGdprkTRnvV_0z4qBcSw292kd9061RplbL3JvYF4yObaTOuEkMRjemPFPzc-vw3xWGVdg==\"\r\nurl = \"https://us-east-1-1.aws.cloud2.influxdata.com\"\r\n\r\n# Initialize InfluxDB client\r\nclient = influxdb_client.InfluxDBClient(\r\n    url=url,\r\n    token=token,\r\n    org=org\r\n)\r\n\r\n# Write API\r\nwrite_api = client.write_api(write_options=SYNCHRONOUS)\r\n\r\ndef get_location():\r\n    response = requests.get(geolocation_api_url)\r\n    if response.status_code == 200:\r\n        data = response.json()\r\n        city_name = data.get('city', '')  # Extract the city name\r\n        return city_name\r\n    else:\r\n        raise Exception(f\"Error fetching location: {response.status_code}\")\r\n\r\ndef fetch_weather_data(city_name):\r\n    city_name='Kanpur'\r\n    weather_url = f\"https://weather.visualcrossing.com/VisualCrossingWebServices/rest/services/timeline/{city_name}?unitGroup=metric&include=days&key={weather_api_key}&contentType=json\"\r\n    response = requests.get(weather_url)\r\n    if response.status_code == 200:\r\n        return response.json()\r\n    else:\r\n        raise Exception(f\"Error fetching weather data: {response.status_code}\")\r\n\r\ndef should_wash_clothes(row):\r\n    score = 0\r\n\r\n    # Precipitation Probability\r\n    if row['precipprob'] > 30:  # Adjusted for UK conditions\r\n        score += 3  # High impact\r\n\r\n    # Humidity\r\n    if row['humidity'] > 75:  # Adjusted threshold\r\n        score += 3  # High impact\r\n\r\n    # Temperature\r\n    if row['temp'] < 10:  # Adjusted for UK climate\r\n        score += 2  # Medium impact\r\n    if row['temp'] > 25:  # Adjusted upper threshold\r\n        score += 1  # High impact\r\n\r\n    # Dew Point\r\n    if row['dew'] > 15:  # Adjusted threshold\r\n        score += 2  # Medium impact\r\n\r\n    # Cloud Cover\r\n    if row['cloudcover'] > 60:  # Slight adjustment\r\n        score += 2  # Medium impact\r\n\r\n    # Wind Speed\r\n    if row['windspeed'] < 7:  # Adjusted for typical UK winds\r\n        score += 2  # Medium impact\r\n\r\n    # Solar Radiation\r\n    if row['solarradiation'] < 150:  # Slight adjustment for UK\r\n        score += 1  # Medium impact\r\n\r\n    # Snow\r\n    if row['snow'] > 0:\r\n        score += 3  # High impact\r\n\r\n    # Visibility\r\n    if row['visibility'] < 5:\r\n        score += 1  # Low impact\r\n\r\n    # UV Index\r\n    if row['uvindex'] < 3:  # Adjusted for typical UK UV levels\r\n        score += 1  # Medium impact\r\n\r\n    # Decision based on score\r\n    if score < 8 and \"Rain\" not in row['conditions']:  # Adjusted threshold\r\n        return \"It's fine to wash clothes today.\"\r\n    else:\r\n        return \"Don't wash clothes today.\"\r\n\r\n@app.route('/weather', methods=['GET'])\r\ndef get_weather_advice():\r\n    try:\r\n        # Fetch the city name from the geolocation API\r\n        city_name = get_location()\r\n        if not city_name:\r\n            raise Exception(\"City name could not be determined.\")\r\n\r\n        # Fetch the weather data for the city\r\n        weather_data = fetch_weather_data(city_name)\r\n        daily_weather = weather_data['days']\r\n\r\n        # Create DataFrame from the data\r\n        df = pd.DataFrame(daily_weather)\r\n\r\n        # Filter data to only include a 7-day window\r\n        current_date = datetime.now().date()\r\n        df['datetime'] = pd.to_datetime(df['datetime']).dt.date\r\n        df = df[df['datetime'] <= current_date + timedelta(days=7)]\r\n\r\n        # Apply the washing advice function and filter for \"It's fine to wash clothes today\"\r\n        df['washing_advice'] = df.apply(should_wash_clothes, axis=1)\r\n        df_filtered = df[df['washing_advice'] == \"It's fine to wash clothes today.\"]\r\n\r\n        # Check if there's a suitable best day\r\n        if len(df_filtered) == 0:\r\n            # No best day found, send today's data instead\r\n            today_data = df[df['datetime'] == current_date].iloc[0] if len(df[df['datetime'] == current_date]) > 0 else None\r\n            \r\n            if today_data is not None:\r\n                best_day_list = [\r\n                    today_data['conditions'],        # Today's condition\r\n                    \"No\",                            # Recommendation\r\n                    \"Nil\",                             # Best day placeholder\r\n                    float(today_data['temp']),      # Today's temperature\r\n                    \"Nil\",                             # Upcoming day placeholder\r\n                    float(today_data['windspeed'])   # Today's wind speed\r\n                ]\r\n            else:\r\n                best_day_list = [\"0\", \"No\", \"0\", 0.0, \"0\", 0.0]  # Fallback if today's data is also missing\r\n\r\n            # Send the best_day_list to InfluxDB\r\n            point = influxdb_client.Point(\"WeatherData\")\\\r\n                .field(\"condition\", best_day_list[0])\\\r\n                .field(\"wash_recommendation\", best_day_list[1])\\\r\n                .field(\"best_day\", best_day_list[2])\\\r\n                .field(\"temperature\", best_day_list[3])\\\r\n                .field(\"upcoming_day\", best_day_list[4])\\\r\n                .field(\"windspeed\", best_day_list[5])\r\n\r\n            # Write point to InfluxDB\r\n            write_api.write(bucket=bucket, org=org, record=point)\r\n\r\n\r\n        else:\r\n            # Collect required information (datetime, windspeed, conditions)\r\n            filtered_data = df_filtered[['datetime', 'temp', 'windspeed', 'conditions']].copy()\r\n\r\n            # Replace \"Clear\" with \"Sunny\" for best day conditions using .loc\r\n            filtered_data.loc[filtered_data['conditions'] == \"Clear\", 'conditions'] = \"Sunny\"\r\n\r\n            # Get the best day and an upcoming day\r\n            best_day_data = filtered_data.iloc[0]  # The best day\r\n            best_day = best_day_data['datetime'].strftime(\"%d/%m/%Y\")\r\n            upcoming_day_data = df[df['datetime'] > best_day_data['datetime']].iloc[0] if len(df[df['datetime'] > best_day_data['datetime']]) > 0 else None\r\n\r\n            if upcoming_day_data is not None:\r\n                upcoming_day = upcoming_day_data['datetime'].strftime(\"%d/%m/%Y\")\r\n                windspeed_upcoming = float(upcoming_day_data['windspeed'])\r\n            else:\r\n                upcoming_day = \"0\"\r\n                windspeed_upcoming = 0.0\r\n\r\n            best_day_list = [\r\n                best_day_data['conditions'],       # \"Sunny\" (replaced Clear)\r\n                \"Yes\",                             # Yes, it's good to wash clothes\r\n                best_day,                          # Best day (e.g., \"22/09/2024\")\r\n                float(best_day_data['temp']),     # Temperature on the best day\r\n                upcoming_day,                      # Upcoming day (e.g., \"23/09/2024\") or \"0\"\r\n                float(best_day_data['windspeed'])  # Wind speed on the best day\r\n            ]\r\n\r\n            # Send the full best_day_list to InfluxDB\r\n            point = influxdb_client.Point(\"WeatherData\")\\\r\n                .field(\"condition\", best_day_list[0])\\\r\n                .field(\"wash_recommendation\", best_day_list[1])\\\r\n                .field(\"best_day\", best_day_list[2])\\\r\n                .field(\"temperature\", best_day_list[3])\\\r\n                .field(\"upcoming_day\", best_day_list[4])\\\r\n                .field(\"windspeed\", best_day_list[5])\r\n\r\n            # Write point to InfluxDB\r\n            write_api.write(bucket=bucket, org=org, record=point)\r\n\r\n        # Return the list in horizontal format as requested\r\n        return jsonify(best_day_list)\r\n\r\n    except Exception as e:\r\n        return jsonify({\"error\": str(e)}), 500\r\n\r\n\r\nif __name__ == '__main__':\r\n    app.run(debug=True)\r\n",
    "roadmap": {
      "next_problem": "LeetCode #15 - Three Sum",
      "concepts_to_learn": [
        "Advanced Hash Map Usage",
        "Time-Space Optimization"
      ],
      "resources": [
        {
          "type": "video",
          "title": "NeetCode - Hash Maps",
          "link": "https://youtu.be/0ZDYRxBvcm8"
        },
        {
          "type": "article",
          "title": "Hash Table Deep Dive",
          "link": "https://www.geeksforgeeks.org/hashing-data-structure/"
        }
      ],
      "weekly_goal": "Master hash map patterns in 4 problems over 3 days"
    }
  },
  {
    "code": "from flask import Flask, jsonify\r\nimport requests\r\nimport pandas as pd\r\nfrom datetime import datetime, timedelta\r\nimport influxdb_client\r\nfrom influxdb_client.client.write_api import SYNCHRONOUS\r\n\r\napp = Flask(__name__)\r\n\r\n# API keys and URLs\r\nweather_api_key = \"CY7T7E66YYDD9CE6BAP5JB9BX\"\r\ngeolocation_api_key = \"5d1f894d5b804ff99f0d5c59a62b1875\"\r\ngeolocation_api_url = f\"https://api.ipgeolocation.io/ipgeo?apiKey={geolocation_api_key}\"\r\n\r\n# InfluxDB configuration\r\nbucket = \"Smart_Home_Energy_managment_System\"\r\norg = \"a2eaff1ac168a82f\"\r\ntoken = \"Skuusy-q0tX5VGiMXFGdprkTRnvV_0z4qBcSw292kd9061RplbL3JvYF4yObaTOuEkMRjemPFPzc-vw3xWGVdg==\"\r\nurl = \"https://us-east-1-1.aws.cloud2.influxdata.com\"\r\n\r\n# Initialize InfluxDB client\r\nclient = influxdb_client.InfluxDBClient(\r\n    url=url,\r\n    token=token,\r\n    org=org\r\n)\r\n\r\n# Write API\r\nwrite_api = client.write_api(write_options=SYNCHRONOUS)\r\n\r\ndef get_location():\r\n    response = requests.get(geolocation_api_url)\r\n    if response.status_code == 200:\r\n        data = response.json()\r\n        city_name = data.get('city', '')  # Extract the city name\r\n        return city_name\r\n    else:\r\n        raise Exception(f\"Error fetching location: {response.status_code}\")\r\n\r\ndef fetch_weather_data(city_name):\r\n    city_name='Kanpur'\r\n    weather_url = f\"https://weather.visualcrossing.com/VisualCrossingWebServices/rest/services/timeline/{city_name}?unitGroup=metric&include=days&key={weather_api_key}&contentType=json\"\r\n    response = requests.get(weather_url)\r\n    if response.status_code == 200:\r\n        return response.json()\r\n    else:\r\n        raise Exception(f\"Error fetching weather data: {response.status_code}\")\r\n\r\ndef should_wash_clothes(row):\r\n    score = 0\r\n\r\n    # Precipitation Probability\r\n    if row['precipprob'] > 30:  # Adjusted for UK conditions\r\n        score += 3  # High impact\r\n\r\n    # Humidity\r\n    if row['humidity'] > 75:  # Adjusted threshold\r\n        score += 3  # High impact\r\n\r\n    # Temperature\r\n    if row['temp'] < 10:  # Adjusted for UK climate\r\n        score += 2  # Medium impact\r\n    if row['temp'] > 25:  # Adjusted upper threshold\r\n        score += 1  # High impact\r\n\r\n    # Dew Point\r\n    if row['dew'] > 15:  # Adjusted threshold\r\n        score += 2  # Medium impact\r\n\r\n    # Cloud Cover\r\n    if row['cloudcover'] > 60:  # Slight adjustment\r\n        score += 2  # Medium impact\r\n\r\n    # Wind Speed\r\n    if row['windspeed'] < 7:  # Adjusted for typical UK winds\r\n        score += 2  # Medium impact\r\n\r\n    # Solar Radiation\r\n    if row['solarradiation'] < 150:  # Slight adjustment for UK\r\n        score += 1  # Medium impact\r\n\r\n    # Snow\r\n    if row['snow'] > 0:\r\n        score += 3  # High impact\r\n\r\n    # Visibility\r\n    if row['visibility'] < 5:\r\n        score += 1  # Low impact\r\n\r\n    # UV Index\r\n    if row['uvindex'] < 3:  # Adjusted for typical UK UV levels\r\n        score += 1  # Medium impact\r\n\r\n    # Decision based on score\r\n    if score < 8 and \"Rain\" not in row['conditions']:  # Adjusted threshold\r\n        return \"It's fine to wash clothes today.\"\r\n    else:\r\n        return \"Don't wash clothes today.\"\r\n\r\n@app.route('/weather', methods=['GET'])\r\ndef get_weather_advice():\r\n    try:\r\n        # Fetch the city name from the geolocation API\r\n        city_name = get_location()\r\n        if not city_name:\r\n            raise Exception(\"City name could not be determined.\")\r\n\r\n        # Fetch the weather data for the city\r\n        weather_data = fetch_weather_data(city_name)\r\n        daily_weather = weather_data['days']\r\n\r\n        # Create DataFrame from the data\r\n        df = pd.DataFrame(daily_weather)\r\n\r\n        # Filter data to only include a 7-day window\r\n        current_date = datetime.now().date()\r\n        df['datetime'] = pd.to_datetime(df['datetime']).dt.date\r\n        df = df[df['datetime'] <= current_date + timedelta(days=7)]\r\n\r\n        # Apply the washing advice function and filter for \"It's fine to wash clothes today\"\r\n        df['washing_advice'] = df.apply(should_wash_clothes, axis=1)\r\n        df_filtered = df[df['washing_advice'] == \"It's fine to wash clothes today.\"]\r\n\r\n        # Check if there's a suitable best day\r\n        if len(df_filtered) == 0:\r\n            # No best day found, send today's data instead\r\n            today_data = df[df['datetime'] == current_date].iloc[0] if len(df[df['datetime'] == current_date]) > 0 else None\r\n            \r\n            if today_data is not None:\r\n                best_day_list = [\r\n                    today_data['conditions'],        # Today's condition\r\n                    \"No\",                            # Recommendation\r\n                    \"Nil\",                             # Best day placeholder\r\n                    float(today_data['temp']),      # Today's temperature\r\n                    \"Nil\",                             # Upcoming day placeholder\r\n                    float(today_data['windspeed'])   # Today's wind speed\r\n                ]\r\n            else:\r\n                best_day_list = [\"0\", \"No\", \"0\", 0.0, \"0\", 0.0]  # Fallback if today's data is also missing\r\n\r\n            # Send the best_day_list to InfluxDB\r\n            point = influxdb_client.Point(\"WeatherData\")\\\r\n                .field(\"condition\", best_day_list[0])\\\r\n                .field(\"wash_recommendation\", best_day_list[1])\\\r\n                .field(\"best_day\", best_day_list[2])\\\r\n                .field(\"temperature\", best_day_list[3])\\\r\n                .field(\"upcoming_day\", best_day_list[4])\\\r\n                .field(\"windspeed\", best_day_list[5])\r\n\r\n            # Write point to InfluxDB\r\n            write_api.write(bucket=bucket, org=org, record=point)\r\n\r\n\r\n        else:\r\n            # Collect required information (datetime, windspeed, conditions)\r\n            filtered_data = df_filtered[['datetime', 'temp', 'windspeed', 'conditions']].copy()\r\n\r\n            # Replace \"Clear\" with \"Sunny\" for best day conditions using .loc\r\n            filtered_data.loc[filtered_data['conditions'] == \"Clear\", 'conditions'] = \"Sunny\"\r\n\r\n            # Get the best day and an upcoming day\r\n            best_day_data = filtered_data.iloc[0]  # The best day\r\n            best_day = best_day_data['datetime'].strftime(\"%d/%m/%Y\")\r\n            upcoming_day_data = df[df['datetime'] > best_day_data['datetime']].iloc[0] if len(df[df['datetime'] > best_day_data['datetime']]) > 0 else None\r\n\r\n            if upcoming_day_data is not None:\r\n                upcoming_day = upcoming_day_data['datetime'].strftime(\"%d/%m/%Y\")\r\n                windspeed_upcoming = float(upcoming_day_data['windspeed'])\r\n            else:\r\n                upcoming_day = \"0\"\r\n                windspeed_upcoming = 0.0\r\n\r\n            best_day_list = [\r\n                best_day_data['conditions'],       # \"Sunny\" (replaced Clear)\r\n                \"Yes\",                             # Yes, it's good to wash clothes\r\n                best_day,                          # Best day (e.g., \"22/09/2024\")\r\n                float(best_day_data['temp']),     # Temperature on the best day\r\n                upcoming_day,                      # Upcoming day (e.g., \"23/09/2024\") or \"0\"\r\n                float(best_day_data['windspeed'])  # Wind speed on the best day\r\n            ]\r\n\r\n            # Send the full best_day_list to InfluxDB\r\n            point = influxdb_client.Point(\"WeatherData\")\\\r\n                .field(\"condition\", best_day_list[0])\\\r\n                .field(\"wash_recommendation\", best_day_list[1])\\\r\n                .field(\"best_day\", best_day_list[2])\\\r\n                .field(\"temperature\", best_day_list[3])\\\r\n                .field(\"upcoming_day\", best_day_list[4])\\\r\n                .field(\"windspeed\", best_day_list[5])\r\n\r\n            # Write point to InfluxDB\r\n            write_api.write(bucket=bucket, org=org, record=point)\r\n\r\n        # Return the list in horizontal format as requested\r\n        return jsonify(best_day_list)\r\n\r\n    except Exception as e:\r\n        return jsonify({\"error\": str(e)}), 500\r\n\r\n\r\nif __name__ == '__main__':\r\n    app.run(debug=True)\r\n",
    "roadmap": {
      "next_problem": "LeetCode #15 - Three Sum",
      "concepts_to_learn": [
        "Advanced Hash Map Usage",
        "Time-Space Optimization"
      ],
      "resources": [
        {
          "type": "video",
          "title": "NeetCode - Hash Maps",
          "link": "https://youtu.be/0ZDYRxBvcm8"
        },
        {
          "type": "article",
          "title": "Hash Table Deep Dive",
          "link": "https://www.geeksforgeeks.org/hashing-data-structure/"
        }
      ],
      "weekly_goal": "Master hash map patterns in 4 problems over 3 days"
    }
  },
  {
    "code": "#influxdb Date and time Write Code\r\n\r\nimport influxdb_client\r\nfrom influxdb_client.client.write_api import SYNCHRONOUS\r\nfrom datetime import datetime\r\n\r\n# Configuration\r\nbucket = \"Esp32\"\r\norg = \"188001aa9267f088\"\r\ntoken = \"7-FtIDytDAxs_zcWNvI_5qe8d3OceCCA_xeAhL4IQvPwGYqY2BEvNHWOV4_5iYlhdXdj6CsvO1ZoJVWB3YSLuA==\"\r\nurl = \"https://us-east-1-1.aws.cloud2.influxdata.com\"\r\n\r\n# Initialize InfluxDB client\r\nclient = influxdb_client.InfluxDBClient(\r\n    url=url,\r\n    token=token,\r\n    org=org\r\n)\r\n\r\n# Write API\r\nwrite_api = client.write_api(write_options=SYNCHRONOUS)\r\n\r\ntemperature = 24.5  # Example temperature value\r\nhumidity = 60.2     # Example humidity value\r\nvoltage = 230.4     # Example voltage value\r\n\r\n# Create a point with current date and time as a string\r\n#current_time = datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\r\ncurrent_time = datetime.now().strftime(\"%Y-%m-%d\")\r\npoint = influxdb_client.Point(\"EnergyMeter\")\\\r\n    .field(\"temperature\", temperature)\r\n\r\n# Write point to InfluxDB\r\nwrite_api.write(bucket=bucket, org=org, record=point)\r\n\r\npoint = influxdb_client.Point(\"EnergyMeter\")\\\r\n    .field(\"humidity\", humidity)\r\n\r\n# Write point to InfluxDB\r\nwrite_api.write(bucket=bucket, org=org, record=point)\r\n\r\npoint = influxdb_client.Point(\"EnergyMeter\")\\\r\n    .field(\"voltage\", voltage)\r\n\r\n# Write point to InfluxDB\r\nwrite_api.write(bucket=bucket, org=org, record=point)\r\n\r\n#print(f\"Written time string: {current_time} to InfluxDB.\")\r\n",
    "roadmap": {
      "next_problem": "LeetCode #1 - Two Sum",
      "concepts_to_learn": [
        "**"
      ],
      "resources": [
        {
          "type": "video",
          "title": "NeetCode - Hash Maps",
          "link": "https://youtu.be/0ZDYRxBvcm8"
        },
        {
          "type": "article",
          "title": "Hash Table Deep Dive",
          "link": "https://www.geeksforgeeks.org/hashing-data-structure/"
        }
      ],
      "weekly_goal": "Solve 3 problems on the concept in 3 days"
    }
  },
  {
    "code": "#influxdb Date and time Write Code\r\n\r\nimport influxdb_client\r\nfrom influxdb_client.client.write_api import SYNCHRONOUS\r\nfrom datetime import datetime\r\n\r\n# Configuration\r\nbucket = \"Esp32\"\r\norg = \"188001aa9267f088\"\r\ntoken = \"7-FtIDytDAxs_zcWNvI_5qe8d3OceCCA_xeAhL4IQvPwGYqY2BEvNHWOV4_5iYlhdXdj6CsvO1ZoJVWB3YSLuA==\"\r\nurl = \"https://us-east-1-1.aws.cloud2.influxdata.com\"\r\n\r\n# Initialize InfluxDB client\r\nclient = influxdb_client.InfluxDBClient(\r\n    url=url,\r\n    token=token,\r\n    org=org\r\n)\r\n\r\n# Write API\r\nwrite_api = client.write_api(write_options=SYNCHRONOUS)\r\n\r\ntemperature = 24.5  # Example temperature value\r\nhumidity = 60.2     # Example humidity value\r\nvoltage = 230.4     # Example voltage value\r\n\r\n# Create a point with current date and time as a string\r\n#current_time = datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\r\ncurrent_time = datetime.now().strftime(\"%Y-%m-%d\")\r\npoint = influxdb_client.Point(\"EnergyMeter\")\\\r\n    .field(\"temperature\", temperature)\r\n\r\n# Write point to InfluxDB\r\nwrite_api.write(bucket=bucket, org=org, record=point)\r\n\r\npoint = influxdb_client.Point(\"EnergyMeter\")\\\r\n    .field(\"humidity\", humidity)\r\n\r\n# Write point to InfluxDB\r\nwrite_api.write(bucket=bucket, org=org, record=point)\r\n\r\npoint = influxdb_client.Point(\"EnergyMeter\")\\\r\n    .field(\"voltage\", voltage)\r\n\r\n# Write point to InfluxDB\r\nwrite_api.write(bucket=bucket, org=org, record=point)\r\n\r\n#print(f\"Written time string: {current_time} to InfluxDB.\")\r\n",
    "roadmap": {
      "next_problem": "",
      "concepts_to_learn": [
        "**"
      ],
      "resources": [],
      "weekly_goal": ""
    }
  }
]