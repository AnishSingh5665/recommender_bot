[
  {
    "code": "from flask import Flask, jsonify\r\nimport requests\r\nimport pandas as pd\r\nfrom datetime import datetime, timedelta\r\nimport influxdb_client\r\nfrom influxdb_client.client.write_api import SYNCHRONOUS\r\n\r\napp = Flask(__name__)\r\n\r\n# API keys and URLs\r\nweather_api_key = \"CY7T7E66YYDD9CE6BAP5JB9BX\"\r\ngeolocation_api_key = \"5d1f894d5b804ff99f0d5c59a62b1875\"\r\ngeolocation_api_url = f\"https://api.ipgeolocation.io/ipgeo?apiKey={geolocation_api_key}\"\r\n\r\n# InfluxDB configuration\r\nbucket = \"Smart_Home_Energy_managment_System\"\r\norg = \"a2eaff1ac168a82f\"\r\ntoken = \"Skuusy-q0tX5VGiMXFGdprkTRnvV_0z4qBcSw292kd9061RplbL3JvYF4yObaTOuEkMRjemPFPzc-vw3xWGVdg==\"\r\nurl = \"https://us-east-1-1.aws.cloud2.influxdata.com\"\r\n\r\n# Initialize InfluxDB client\r\nclient = influxdb_client.InfluxDBClient(\r\n    url=url,\r\n    token=token,\r\n    org=org\r\n)\r\n\r\n# Write API\r\nwrite_api = client.write_api(write_options=SYNCHRONOUS)\r\n\r\ndef get_location():\r\n    response = requests.get(geolocation_api_url)\r\n    if response.status_code == 200:\r\n        data = response.json()\r\n        city_name = data.get('city', '')  # Extract the city name\r\n        return city_name\r\n    else:\r\n        raise Exception(f\"Error fetching location: {response.status_code}\")\r\n\r\ndef fetch_weather_data(city_name):\r\n    city_name='Kanpur'\r\n    weather_url = f\"https://weather.visualcrossing.com/VisualCrossingWebServices/rest/services/timeline/{city_name}?unitGroup=metric&include=days&key={weather_api_key}&contentType=json\"\r\n    response = requests.get(weather_url)\r\n    if response.status_code == 200:\r\n        return response.json()\r\n    else:\r\n        raise Exception(f\"Error fetching weather data: {response.status_code}\")\r\n\r\ndef should_wash_clothes(row):\r\n    score = 0\r\n\r\n    # Precipitation Probability\r\n    if row['precipprob'] > 30:  # Adjusted for UK conditions\r\n        score += 3  # High impact\r\n\r\n    # Humidity\r\n    if row['humidity'] > 75:  # Adjusted threshold\r\n        score += 3  # High impact\r\n\r\n    # Temperature\r\n    if row['temp'] < 10:  # Adjusted for UK climate\r\n        score += 2  # Medium impact\r\n    if row['temp'] > 25:  # Adjusted upper threshold\r\n        score += 1  # High impact\r\n\r\n    # Dew Point\r\n    if row['dew'] > 15:  # Adjusted threshold\r\n        score += 2  # Medium impact\r\n\r\n    # Cloud Cover\r\n    if row['cloudcover'] > 60:  # Slight adjustment\r\n        score += 2  # Medium impact\r\n\r\n    # Wind Speed\r\n    if row['windspeed'] < 7:  # Adjusted for typical UK winds\r\n        score += 2  # Medium impact\r\n\r\n    # Solar Radiation\r\n    if row['solarradiation'] < 150:  # Slight adjustment for UK\r\n        score += 1  # Medium impact\r\n\r\n    # Snow\r\n    if row['snow'] > 0:\r\n        score += 3  # High impact\r\n\r\n    # Visibility\r\n    if row['visibility'] < 5:\r\n        score += 1  # Low impact\r\n\r\n    # UV Index\r\n    if row['uvindex'] < 3:  # Adjusted for typical UK UV levels\r\n        score += 1  # Medium impact\r\n\r\n    # Decision based on score\r\n    if score < 8 and \"Rain\" not in row['conditions']:  # Adjusted threshold\r\n        return \"It's fine to wash clothes today.\"\r\n    else:\r\n        return \"Don't wash clothes today.\"\r\n\r\n@app.route('/weather', methods=['GET'])\r\ndef get_weather_advice():\r\n    try:\r\n        # Fetch the city name from the geolocation API\r\n        city_name = get_location()\r\n        if not city_name:\r\n            raise Exception(\"City name could not be determined.\")\r\n\r\n        # Fetch the weather data for the city\r\n        weather_data = fetch_weather_data(city_name)\r\n        daily_weather = weather_data['days']\r\n\r\n        # Create DataFrame from the data\r\n        df = pd.DataFrame(daily_weather)\r\n\r\n        # Filter data to only include a 7-day window\r\n        current_date = datetime.now().date()\r\n        df['datetime'] = pd.to_datetime(df['datetime']).dt.date\r\n        df = df[df['datetime'] <= current_date + timedelta(days=7)]\r\n\r\n        # Apply the washing advice function and filter for \"It's fine to wash clothes today\"\r\n        df['washing_advice'] = df.apply(should_wash_clothes, axis=1)\r\n        df_filtered = df[df['washing_advice'] == \"It's fine to wash clothes today.\"]\r\n\r\n        # Check if there's a suitable best day\r\n        if len(df_filtered) == 0:\r\n            # No best day found, send today's data instead\r\n            today_data = df[df['datetime'] == current_date].iloc[0] if len(df[df['datetime'] == current_date]) > 0 else None\r\n            \r\n            if today_data is not None:\r\n                best_day_list = [\r\n                    today_data['conditions'],        # Today's condition\r\n                    \"No\",                            # Recommendation\r\n                    \"Nil\",                             # Best day placeholder\r\n                    float(today_data['temp']),      # Today's temperature\r\n                    \"Nil\",                             # Upcoming day placeholder\r\n                    float(today_data['windspeed'])   # Today's wind speed\r\n                ]\r\n            else:\r\n                best_day_list = [\"0\", \"No\", \"0\", 0.0, \"0\", 0.0]  # Fallback if today's data is also missing\r\n\r\n            # Send the best_day_list to InfluxDB\r\n            point = influxdb_client.Point(\"WeatherData\")\\\r\n                .field(\"condition\", best_day_list[0])\\\r\n                .field(\"wash_recommendation\", best_day_list[1])\\\r\n                .field(\"best_day\", best_day_list[2])\\\r\n                .field(\"temperature\", best_day_list[3])\\\r\n                .field(\"upcoming_day\", best_day_list[4])\\\r\n                .field(\"windspeed\", best_day_list[5])\r\n\r\n            # Write point to InfluxDB\r\n            write_api.write(bucket=bucket, org=org, record=point)\r\n\r\n\r\n        else:\r\n            # Collect required information (datetime, windspeed, conditions)\r\n            filtered_data = df_filtered[['datetime', 'temp', 'windspeed', 'conditions']].copy()\r\n\r\n            # Replace \"Clear\" with \"Sunny\" for best day conditions using .loc\r\n            filtered_data.loc[filtered_data['conditions'] == \"Clear\", 'conditions'] = \"Sunny\"\r\n\r\n            # Get the best day and an upcoming day\r\n            best_day_data = filtered_data.iloc[0]  # The best day\r\n            best_day = best_day_data['datetime'].strftime(\"%d/%m/%Y\")\r\n            upcoming_day_data = df[df['datetime'] > best_day_data['datetime']].iloc[0] if len(df[df['datetime'] > best_day_data['datetime']]) > 0 else None\r\n\r\n            if upcoming_day_data is not None:\r\n                upcoming_day = upcoming_day_data['datetime'].strftime(\"%d/%m/%Y\")\r\n                windspeed_upcoming = float(upcoming_day_data['windspeed'])\r\n            else:\r\n                upcoming_day = \"0\"\r\n                windspeed_upcoming = 0.0\r\n\r\n            best_day_list = [\r\n                best_day_data['conditions'],       # \"Sunny\" (replaced Clear)\r\n                \"Yes\",                             # Yes, it's good to wash clothes\r\n                best_day,                          # Best day (e.g., \"22/09/2024\")\r\n                float(best_day_data['temp']),     # Temperature on the best day\r\n                upcoming_day,                      # Upcoming day (e.g., \"23/09/2024\") or \"0\"\r\n                float(best_day_data['windspeed'])  # Wind speed on the best day\r\n            ]\r\n\r\n            # Send the full best_day_list to InfluxDB\r\n            point = influxdb_client.Point(\"WeatherData\")\\\r\n                .field(\"condition\", best_day_list[0])\\\r\n                .field(\"wash_recommendation\", best_day_list[1])\\\r\n                .field(\"best_day\", best_day_list[2])\\\r\n                .field(\"temperature\", best_day_list[3])\\\r\n                .field(\"upcoming_day\", best_day_list[4])\\\r\n                .field(\"windspeed\", best_day_list[5])\r\n\r\n            # Write point to InfluxDB\r\n            write_api.write(bucket=bucket, org=org, record=point)\r\n\r\n        # Return the list in horizontal format as requested\r\n        return jsonify(best_day_list)\r\n\r\n    except Exception as e:\r\n        return jsonify({\"error\": str(e)}), 500\r\n\r\n\r\nif __name__ == '__main__':\r\n    app.run(debug=True)\r\n",
    "roadmap": {
      "next_problem": "LeetCode #15 - Three Sum",
      "concepts_to_learn": [
        "Advanced Hash Map Usage",
        "Time-Space Optimization"
      ],
      "resources": [
        {
          "type": "video",
          "title": "NeetCode - Hash Maps",
          "link": "https://youtu.be/0ZDYRxBvcm8"
        },
        {
          "type": "article",
          "title": "Hash Table Deep Dive",
          "link": "https://www.geeksforgeeks.org/hashing-data-structure/"
        }
      ],
      "weekly_goal": "Master hash map patterns in 4 problems over 3 days"
    }
  },
  {
    "code": "from flask import Flask, jsonify\r\nimport requests\r\nimport pandas as pd\r\nfrom datetime import datetime, timedelta\r\nimport influxdb_client\r\nfrom influxdb_client.client.write_api import SYNCHRONOUS\r\n\r\napp = Flask(__name__)\r\n\r\n# API keys and URLs\r\nweather_api_key = \"CY7T7E66YYDD9CE6BAP5JB9BX\"\r\ngeolocation_api_key = \"5d1f894d5b804ff99f0d5c59a62b1875\"\r\ngeolocation_api_url = f\"https://api.ipgeolocation.io/ipgeo?apiKey={geolocation_api_key}\"\r\n\r\n# InfluxDB configuration\r\nbucket = \"Smart_Home_Energy_managment_System\"\r\norg = \"a2eaff1ac168a82f\"\r\ntoken = \"Skuusy-q0tX5VGiMXFGdprkTRnvV_0z4qBcSw292kd9061RplbL3JvYF4yObaTOuEkMRjemPFPzc-vw3xWGVdg==\"\r\nurl = \"https://us-east-1-1.aws.cloud2.influxdata.com\"\r\n\r\n# Initialize InfluxDB client\r\nclient = influxdb_client.InfluxDBClient(\r\n    url=url,\r\n    token=token,\r\n    org=org\r\n)\r\n\r\n# Write API\r\nwrite_api = client.write_api(write_options=SYNCHRONOUS)\r\n\r\ndef get_location():\r\n    response = requests.get(geolocation_api_url)\r\n    if response.status_code == 200:\r\n        data = response.json()\r\n        city_name = data.get('city', '')  # Extract the city name\r\n        return city_name\r\n    else:\r\n        raise Exception(f\"Error fetching location: {response.status_code}\")\r\n\r\ndef fetch_weather_data(city_name):\r\n    city_name='Kanpur'\r\n    weather_url = f\"https://weather.visualcrossing.com/VisualCrossingWebServices/rest/services/timeline/{city_name}?unitGroup=metric&include=days&key={weather_api_key}&contentType=json\"\r\n    response = requests.get(weather_url)\r\n    if response.status_code == 200:\r\n        return response.json()\r\n    else:\r\n        raise Exception(f\"Error fetching weather data: {response.status_code}\")\r\n\r\ndef should_wash_clothes(row):\r\n    score = 0\r\n\r\n    # Precipitation Probability\r\n    if row['precipprob'] > 30:  # Adjusted for UK conditions\r\n        score += 3  # High impact\r\n\r\n    # Humidity\r\n    if row['humidity'] > 75:  # Adjusted threshold\r\n        score += 3  # High impact\r\n\r\n    # Temperature\r\n    if row['temp'] < 10:  # Adjusted for UK climate\r\n        score += 2  # Medium impact\r\n    if row['temp'] > 25:  # Adjusted upper threshold\r\n        score += 1  # High impact\r\n\r\n    # Dew Point\r\n    if row['dew'] > 15:  # Adjusted threshold\r\n        score += 2  # Medium impact\r\n\r\n    # Cloud Cover\r\n    if row['cloudcover'] > 60:  # Slight adjustment\r\n        score += 2  # Medium impact\r\n\r\n    # Wind Speed\r\n    if row['windspeed'] < 7:  # Adjusted for typical UK winds\r\n        score += 2  # Medium impact\r\n\r\n    # Solar Radiation\r\n    if row['solarradiation'] < 150:  # Slight adjustment for UK\r\n        score += 1  # Medium impact\r\n\r\n    # Snow\r\n    if row['snow'] > 0:\r\n        score += 3  # High impact\r\n\r\n    # Visibility\r\n    if row['visibility'] < 5:\r\n        score += 1  # Low impact\r\n\r\n    # UV Index\r\n    if row['uvindex'] < 3:  # Adjusted for typical UK UV levels\r\n        score += 1  # Medium impact\r\n\r\n    # Decision based on score\r\n    if score < 8 and \"Rain\" not in row['conditions']:  # Adjusted threshold\r\n        return \"It's fine to wash clothes today.\"\r\n    else:\r\n        return \"Don't wash clothes today.\"\r\n\r\n@app.route('/weather', methods=['GET'])\r\ndef get_weather_advice():\r\n    try:\r\n        # Fetch the city name from the geolocation API\r\n        city_name = get_location()\r\n        if not city_name:\r\n            raise Exception(\"City name could not be determined.\")\r\n\r\n        # Fetch the weather data for the city\r\n        weather_data = fetch_weather_data(city_name)\r\n        daily_weather = weather_data['days']\r\n\r\n        # Create DataFrame from the data\r\n        df = pd.DataFrame(daily_weather)\r\n\r\n        # Filter data to only include a 7-day window\r\n        current_date = datetime.now().date()\r\n        df['datetime'] = pd.to_datetime(df['datetime']).dt.date\r\n        df = df[df['datetime'] <= current_date + timedelta(days=7)]\r\n\r\n        # Apply the washing advice function and filter for \"It's fine to wash clothes today\"\r\n        df['washing_advice'] = df.apply(should_wash_clothes, axis=1)\r\n        df_filtered = df[df['washing_advice'] == \"It's fine to wash clothes today.\"]\r\n\r\n        # Check if there's a suitable best day\r\n        if len(df_filtered) == 0:\r\n            # No best day found, send today's data instead\r\n            today_data = df[df['datetime'] == current_date].iloc[0] if len(df[df['datetime'] == current_date]) > 0 else None\r\n            \r\n            if today_data is not None:\r\n                best_day_list = [\r\n                    today_data['conditions'],        # Today's condition\r\n                    \"No\",                            # Recommendation\r\n                    \"Nil\",                             # Best day placeholder\r\n                    float(today_data['temp']),      # Today's temperature\r\n                    \"Nil\",                             # Upcoming day placeholder\r\n                    float(today_data['windspeed'])   # Today's wind speed\r\n                ]\r\n            else:\r\n                best_day_list = [\"0\", \"No\", \"0\", 0.0, \"0\", 0.0]  # Fallback if today's data is also missing\r\n\r\n            # Send the best_day_list to InfluxDB\r\n            point = influxdb_client.Point(\"WeatherData\")\\\r\n                .field(\"condition\", best_day_list[0])\\\r\n                .field(\"wash_recommendation\", best_day_list[1])\\\r\n                .field(\"best_day\", best_day_list[2])\\\r\n                .field(\"temperature\", best_day_list[3])\\\r\n                .field(\"upcoming_day\", best_day_list[4])\\\r\n                .field(\"windspeed\", best_day_list[5])\r\n\r\n            # Write point to InfluxDB\r\n            write_api.write(bucket=bucket, org=org, record=point)\r\n\r\n\r\n        else:\r\n            # Collect required information (datetime, windspeed, conditions)\r\n            filtered_data = df_filtered[['datetime', 'temp', 'windspeed', 'conditions']].copy()\r\n\r\n            # Replace \"Clear\" with \"Sunny\" for best day conditions using .loc\r\n            filtered_data.loc[filtered_data['conditions'] == \"Clear\", 'conditions'] = \"Sunny\"\r\n\r\n            # Get the best day and an upcoming day\r\n            best_day_data = filtered_data.iloc[0]  # The best day\r\n            best_day = best_day_data['datetime'].strftime(\"%d/%m/%Y\")\r\n            upcoming_day_data = df[df['datetime'] > best_day_data['datetime']].iloc[0] if len(df[df['datetime'] > best_day_data['datetime']]) > 0 else None\r\n\r\n            if upcoming_day_data is not None:\r\n                upcoming_day = upcoming_day_data['datetime'].strftime(\"%d/%m/%Y\")\r\n                windspeed_upcoming = float(upcoming_day_data['windspeed'])\r\n            else:\r\n                upcoming_day = \"0\"\r\n                windspeed_upcoming = 0.0\r\n\r\n            best_day_list = [\r\n                best_day_data['conditions'],       # \"Sunny\" (replaced Clear)\r\n                \"Yes\",                             # Yes, it's good to wash clothes\r\n                best_day,                          # Best day (e.g., \"22/09/2024\")\r\n                float(best_day_data['temp']),     # Temperature on the best day\r\n                upcoming_day,                      # Upcoming day (e.g., \"23/09/2024\") or \"0\"\r\n                float(best_day_data['windspeed'])  # Wind speed on the best day\r\n            ]\r\n\r\n            # Send the full best_day_list to InfluxDB\r\n            point = influxdb_client.Point(\"WeatherData\")\\\r\n                .field(\"condition\", best_day_list[0])\\\r\n                .field(\"wash_recommendation\", best_day_list[1])\\\r\n                .field(\"best_day\", best_day_list[2])\\\r\n                .field(\"temperature\", best_day_list[3])\\\r\n                .field(\"upcoming_day\", best_day_list[4])\\\r\n                .field(\"windspeed\", best_day_list[5])\r\n\r\n            # Write point to InfluxDB\r\n            write_api.write(bucket=bucket, org=org, record=point)\r\n\r\n        # Return the list in horizontal format as requested\r\n        return jsonify(best_day_list)\r\n\r\n    except Exception as e:\r\n        return jsonify({\"error\": str(e)}), 500\r\n\r\n\r\nif __name__ == '__main__':\r\n    app.run(debug=True)\r\n",
    "roadmap": {
      "next_problem": "LeetCode #15 - Three Sum",
      "concepts_to_learn": [
        "Advanced Hash Map Usage",
        "Time-Space Optimization"
      ],
      "resources": [
        {
          "type": "video",
          "title": "NeetCode - Hash Maps",
          "link": "https://youtu.be/0ZDYRxBvcm8"
        },
        {
          "type": "article",
          "title": "Hash Table Deep Dive",
          "link": "https://www.geeksforgeeks.org/hashing-data-structure/"
        }
      ],
      "weekly_goal": "Master hash map patterns in 4 problems over 3 days"
    }
  },
  {
    "code": "from flask import Flask, jsonify\r\nimport requests\r\nimport pandas as pd\r\nfrom datetime import datetime, timedelta\r\nimport influxdb_client\r\nfrom influxdb_client.client.write_api import SYNCHRONOUS\r\n\r\napp = Flask(__name__)\r\n\r\n# API keys and URLs\r\nweather_api_key = \"CY7T7E66YYDD9CE6BAP5JB9BX\"\r\ngeolocation_api_key = \"5d1f894d5b804ff99f0d5c59a62b1875\"\r\ngeolocation_api_url = f\"https://api.ipgeolocation.io/ipgeo?apiKey={geolocation_api_key}\"\r\n\r\n# InfluxDB configuration\r\nbucket = \"Smart_Home_Energy_managment_System\"\r\norg = \"a2eaff1ac168a82f\"\r\ntoken = \"Skuusy-q0tX5VGiMXFGdprkTRnvV_0z4qBcSw292kd9061RplbL3JvYF4yObaTOuEkMRjemPFPzc-vw3xWGVdg==\"\r\nurl = \"https://us-east-1-1.aws.cloud2.influxdata.com\"\r\n\r\n# Initialize InfluxDB client\r\nclient = influxdb_client.InfluxDBClient(\r\n    url=url,\r\n    token=token,\r\n    org=org\r\n)\r\n\r\n# Write API\r\nwrite_api = client.write_api(write_options=SYNCHRONOUS)\r\n\r\ndef get_location():\r\n    response = requests.get(geolocation_api_url)\r\n    if response.status_code == 200:\r\n        data = response.json()\r\n        city_name = data.get('city', '')  # Extract the city name\r\n        return city_name\r\n    else:\r\n        raise Exception(f\"Error fetching location: {response.status_code}\")\r\n\r\ndef fetch_weather_data(city_name):\r\n    city_name='Kanpur'\r\n    weather_url = f\"https://weather.visualcrossing.com/VisualCrossingWebServices/rest/services/timeline/{city_name}?unitGroup=metric&include=days&key={weather_api_key}&contentType=json\"\r\n    response = requests.get(weather_url)\r\n    if response.status_code == 200:\r\n        return response.json()\r\n    else:\r\n        raise Exception(f\"Error fetching weather data: {response.status_code}\")\r\n\r\ndef should_wash_clothes(row):\r\n    score = 0\r\n\r\n    # Precipitation Probability\r\n    if row['precipprob'] > 30:  # Adjusted for UK conditions\r\n        score += 3  # High impact\r\n\r\n    # Humidity\r\n    if row['humidity'] > 75:  # Adjusted threshold\r\n        score += 3  # High impact\r\n\r\n    # Temperature\r\n    if row['temp'] < 10:  # Adjusted for UK climate\r\n        score += 2  # Medium impact\r\n    if row['temp'] > 25:  # Adjusted upper threshold\r\n        score += 1  # High impact\r\n\r\n    # Dew Point\r\n    if row['dew'] > 15:  # Adjusted threshold\r\n        score += 2  # Medium impact\r\n\r\n    # Cloud Cover\r\n    if row['cloudcover'] > 60:  # Slight adjustment\r\n        score += 2  # Medium impact\r\n\r\n    # Wind Speed\r\n    if row['windspeed'] < 7:  # Adjusted for typical UK winds\r\n        score += 2  # Medium impact\r\n\r\n    # Solar Radiation\r\n    if row['solarradiation'] < 150:  # Slight adjustment for UK\r\n        score += 1  # Medium impact\r\n\r\n    # Snow\r\n    if row['snow'] > 0:\r\n        score += 3  # High impact\r\n\r\n    # Visibility\r\n    if row['visibility'] < 5:\r\n        score += 1  # Low impact\r\n\r\n    # UV Index\r\n    if row['uvindex'] < 3:  # Adjusted for typical UK UV levels\r\n        score += 1  # Medium impact\r\n\r\n    # Decision based on score\r\n    if score < 8 and \"Rain\" not in row['conditions']:  # Adjusted threshold\r\n        return \"It's fine to wash clothes today.\"\r\n    else:\r\n        return \"Don't wash clothes today.\"\r\n\r\n@app.route('/weather', methods=['GET'])\r\ndef get_weather_advice():\r\n    try:\r\n        # Fetch the city name from the geolocation API\r\n        city_name = get_location()\r\n        if not city_name:\r\n            raise Exception(\"City name could not be determined.\")\r\n\r\n        # Fetch the weather data for the city\r\n        weather_data = fetch_weather_data(city_name)\r\n        daily_weather = weather_data['days']\r\n\r\n        # Create DataFrame from the data\r\n        df = pd.DataFrame(daily_weather)\r\n\r\n        # Filter data to only include a 7-day window\r\n        current_date = datetime.now().date()\r\n        df['datetime'] = pd.to_datetime(df['datetime']).dt.date\r\n        df = df[df['datetime'] <= current_date + timedelta(days=7)]\r\n\r\n        # Apply the washing advice function and filter for \"It's fine to wash clothes today\"\r\n        df['washing_advice'] = df.apply(should_wash_clothes, axis=1)\r\n        df_filtered = df[df['washing_advice'] == \"It's fine to wash clothes today.\"]\r\n\r\n        # Check if there's a suitable best day\r\n        if len(df_filtered) == 0:\r\n            # No best day found, send today's data instead\r\n            today_data = df[df['datetime'] == current_date].iloc[0] if len(df[df['datetime'] == current_date]) > 0 else None\r\n            \r\n            if today_data is not None:\r\n                best_day_list = [\r\n                    today_data['conditions'],        # Today's condition\r\n                    \"No\",                            # Recommendation\r\n                    \"Nil\",                             # Best day placeholder\r\n                    float(today_data['temp']),      # Today's temperature\r\n                    \"Nil\",                             # Upcoming day placeholder\r\n                    float(today_data['windspeed'])   # Today's wind speed\r\n                ]\r\n            else:\r\n                best_day_list = [\"0\", \"No\", \"0\", 0.0, \"0\", 0.0]  # Fallback if today's data is also missing\r\n\r\n            # Send the best_day_list to InfluxDB\r\n            point = influxdb_client.Point(\"WeatherData\")\\\r\n                .field(\"condition\", best_day_list[0])\\\r\n                .field(\"wash_recommendation\", best_day_list[1])\\\r\n                .field(\"best_day\", best_day_list[2])\\\r\n                .field(\"temperature\", best_day_list[3])\\\r\n                .field(\"upcoming_day\", best_day_list[4])\\\r\n                .field(\"windspeed\", best_day_list[5])\r\n\r\n            # Write point to InfluxDB\r\n            write_api.write(bucket=bucket, org=org, record=point)\r\n\r\n\r\n        else:\r\n            # Collect required information (datetime, windspeed, conditions)\r\n            filtered_data = df_filtered[['datetime', 'temp', 'windspeed', 'conditions']].copy()\r\n\r\n            # Replace \"Clear\" with \"Sunny\" for best day conditions using .loc\r\n            filtered_data.loc[filtered_data['conditions'] == \"Clear\", 'conditions'] = \"Sunny\"\r\n\r\n            # Get the best day and an upcoming day\r\n            best_day_data = filtered_data.iloc[0]  # The best day\r\n            best_day = best_day_data['datetime'].strftime(\"%d/%m/%Y\")\r\n            upcoming_day_data = df[df['datetime'] > best_day_data['datetime']].iloc[0] if len(df[df['datetime'] > best_day_data['datetime']]) > 0 else None\r\n\r\n            if upcoming_day_data is not None:\r\n                upcoming_day = upcoming_day_data['datetime'].strftime(\"%d/%m/%Y\")\r\n                windspeed_upcoming = float(upcoming_day_data['windspeed'])\r\n            else:\r\n                upcoming_day = \"0\"\r\n                windspeed_upcoming = 0.0\r\n\r\n            best_day_list = [\r\n                best_day_data['conditions'],       # \"Sunny\" (replaced Clear)\r\n                \"Yes\",                             # Yes, it's good to wash clothes\r\n                best_day,                          # Best day (e.g., \"22/09/2024\")\r\n                float(best_day_data['temp']),     # Temperature on the best day\r\n                upcoming_day,                      # Upcoming day (e.g., \"23/09/2024\") or \"0\"\r\n                float(best_day_data['windspeed'])  # Wind speed on the best day\r\n            ]\r\n\r\n            # Send the full best_day_list to InfluxDB\r\n            point = influxdb_client.Point(\"WeatherData\")\\\r\n                .field(\"condition\", best_day_list[0])\\\r\n                .field(\"wash_recommendation\", best_day_list[1])\\\r\n                .field(\"best_day\", best_day_list[2])\\\r\n                .field(\"temperature\", best_day_list[3])\\\r\n                .field(\"upcoming_day\", best_day_list[4])\\\r\n                .field(\"windspeed\", best_day_list[5])\r\n\r\n            # Write point to InfluxDB\r\n            write_api.write(bucket=bucket, org=org, record=point)\r\n\r\n        # Return the list in horizontal format as requested\r\n        return jsonify(best_day_list)\r\n\r\n    except Exception as e:\r\n        return jsonify({\"error\": str(e)}), 500\r\n\r\n\r\nif __name__ == '__main__':\r\n    app.run(debug=True)\r\n",
    "roadmap": {
      "next_problem": "LeetCode #15 - Three Sum",
      "concepts_to_learn": [
        "Advanced Hash Map Usage",
        "Time-Space Optimization"
      ],
      "resources": [
        {
          "type": "video",
          "title": "NeetCode - Hash Maps",
          "link": "https://youtu.be/0ZDYRxBvcm8"
        },
        {
          "type": "article",
          "title": "Hash Table Deep Dive",
          "link": "https://www.geeksforgeeks.org/hashing-data-structure/"
        }
      ],
      "weekly_goal": "Master hash map patterns in 4 problems over 3 days"
    }
  },
  {
    "code": "from flask import Flask, jsonify\r\nimport requests\r\nimport pandas as pd\r\nfrom datetime import datetime, timedelta\r\nimport influxdb_client\r\nfrom influxdb_client.client.write_api import SYNCHRONOUS\r\n\r\napp = Flask(__name__)\r\n\r\n# API keys and URLs\r\nweather_api_key = \"CY7T7E66YYDD9CE6BAP5JB9BX\"\r\ngeolocation_api_key = \"5d1f894d5b804ff99f0d5c59a62b1875\"\r\ngeolocation_api_url = f\"https://api.ipgeolocation.io/ipgeo?apiKey={geolocation_api_key}\"\r\n\r\n# InfluxDB configuration\r\nbucket = \"Smart_Home_Energy_managment_System\"\r\norg = \"a2eaff1ac168a82f\"\r\ntoken = \"Skuusy-q0tX5VGiMXFGdprkTRnvV_0z4qBcSw292kd9061RplbL3JvYF4yObaTOuEkMRjemPFPzc-vw3xWGVdg==\"\r\nurl = \"https://us-east-1-1.aws.cloud2.influxdata.com\"\r\n\r\n# Initialize InfluxDB client\r\nclient = influxdb_client.InfluxDBClient(\r\n    url=url,\r\n    token=token,\r\n    org=org\r\n)\r\n\r\n# Write API\r\nwrite_api = client.write_api(write_options=SYNCHRONOUS)\r\n\r\ndef get_location():\r\n    response = requests.get(geolocation_api_url)\r\n    if response.status_code == 200:\r\n        data = response.json()\r\n        city_name = data.get('city', '')  # Extract the city name\r\n        return city_name\r\n    else:\r\n        raise Exception(f\"Error fetching location: {response.status_code}\")\r\n\r\ndef fetch_weather_data(city_name):\r\n    city_name='Kanpur'\r\n    weather_url = f\"https://weather.visualcrossing.com/VisualCrossingWebServices/rest/services/timeline/{city_name}?unitGroup=metric&include=days&key={weather_api_key}&contentType=json\"\r\n    response = requests.get(weather_url)\r\n    if response.status_code == 200:\r\n        return response.json()\r\n    else:\r\n        raise Exception(f\"Error fetching weather data: {response.status_code}\")\r\n\r\ndef should_wash_clothes(row):\r\n    score = 0\r\n\r\n    # Precipitation Probability\r\n    if row['precipprob'] > 30:  # Adjusted for UK conditions\r\n        score += 3  # High impact\r\n\r\n    # Humidity\r\n    if row['humidity'] > 75:  # Adjusted threshold\r\n        score += 3  # High impact\r\n\r\n    # Temperature\r\n    if row['temp'] < 10:  # Adjusted for UK climate\r\n        score += 2  # Medium impact\r\n    if row['temp'] > 25:  # Adjusted upper threshold\r\n        score += 1  # High impact\r\n\r\n    # Dew Point\r\n    if row['dew'] > 15:  # Adjusted threshold\r\n        score += 2  # Medium impact\r\n\r\n    # Cloud Cover\r\n    if row['cloudcover'] > 60:  # Slight adjustment\r\n        score += 2  # Medium impact\r\n\r\n    # Wind Speed\r\n    if row['windspeed'] < 7:  # Adjusted for typical UK winds\r\n        score += 2  # Medium impact\r\n\r\n    # Solar Radiation\r\n    if row['solarradiation'] < 150:  # Slight adjustment for UK\r\n        score += 1  # Medium impact\r\n\r\n    # Snow\r\n    if row['snow'] > 0:\r\n        score += 3  # High impact\r\n\r\n    # Visibility\r\n    if row['visibility'] < 5:\r\n        score += 1  # Low impact\r\n\r\n    # UV Index\r\n    if row['uvindex'] < 3:  # Adjusted for typical UK UV levels\r\n        score += 1  # Medium impact\r\n\r\n    # Decision based on score\r\n    if score < 8 and \"Rain\" not in row['conditions']:  # Adjusted threshold\r\n        return \"It's fine to wash clothes today.\"\r\n    else:\r\n        return \"Don't wash clothes today.\"\r\n\r\n@app.route('/weather', methods=['GET'])\r\ndef get_weather_advice():\r\n    try:\r\n        # Fetch the city name from the geolocation API\r\n        city_name = get_location()\r\n        if not city_name:\r\n            raise Exception(\"City name could not be determined.\")\r\n\r\n        # Fetch the weather data for the city\r\n        weather_data = fetch_weather_data(city_name)\r\n        daily_weather = weather_data['days']\r\n\r\n        # Create DataFrame from the data\r\n        df = pd.DataFrame(daily_weather)\r\n\r\n        # Filter data to only include a 7-day window\r\n        current_date = datetime.now().date()\r\n        df['datetime'] = pd.to_datetime(df['datetime']).dt.date\r\n        df = df[df['datetime'] <= current_date + timedelta(days=7)]\r\n\r\n        # Apply the washing advice function and filter for \"It's fine to wash clothes today\"\r\n        df['washing_advice'] = df.apply(should_wash_clothes, axis=1)\r\n        df_filtered = df[df['washing_advice'] == \"It's fine to wash clothes today.\"]\r\n\r\n        # Check if there's a suitable best day\r\n        if len(df_filtered) == 0:\r\n            # No best day found, send today's data instead\r\n            today_data = df[df['datetime'] == current_date].iloc[0] if len(df[df['datetime'] == current_date]) > 0 else None\r\n            \r\n            if today_data is not None:\r\n                best_day_list = [\r\n                    today_data['conditions'],        # Today's condition\r\n                    \"No\",                            # Recommendation\r\n                    \"Nil\",                             # Best day placeholder\r\n                    float(today_data['temp']),      # Today's temperature\r\n                    \"Nil\",                             # Upcoming day placeholder\r\n                    float(today_data['windspeed'])   # Today's wind speed\r\n                ]\r\n            else:\r\n                best_day_list = [\"0\", \"No\", \"0\", 0.0, \"0\", 0.0]  # Fallback if today's data is also missing\r\n\r\n            # Send the best_day_list to InfluxDB\r\n            point = influxdb_client.Point(\"WeatherData\")\\\r\n                .field(\"condition\", best_day_list[0])\\\r\n                .field(\"wash_recommendation\", best_day_list[1])\\\r\n                .field(\"best_day\", best_day_list[2])\\\r\n                .field(\"temperature\", best_day_list[3])\\\r\n                .field(\"upcoming_day\", best_day_list[4])\\\r\n                .field(\"windspeed\", best_day_list[5])\r\n\r\n            # Write point to InfluxDB\r\n            write_api.write(bucket=bucket, org=org, record=point)\r\n\r\n\r\n        else:\r\n            # Collect required information (datetime, windspeed, conditions)\r\n            filtered_data = df_filtered[['datetime', 'temp', 'windspeed', 'conditions']].copy()\r\n\r\n            # Replace \"Clear\" with \"Sunny\" for best day conditions using .loc\r\n            filtered_data.loc[filtered_data['conditions'] == \"Clear\", 'conditions'] = \"Sunny\"\r\n\r\n            # Get the best day and an upcoming day\r\n            best_day_data = filtered_data.iloc[0]  # The best day\r\n            best_day = best_day_data['datetime'].strftime(\"%d/%m/%Y\")\r\n            upcoming_day_data = df[df['datetime'] > best_day_data['datetime']].iloc[0] if len(df[df['datetime'] > best_day_data['datetime']]) > 0 else None\r\n\r\n            if upcoming_day_data is not None:\r\n                upcoming_day = upcoming_day_data['datetime'].strftime(\"%d/%m/%Y\")\r\n                windspeed_upcoming = float(upcoming_day_data['windspeed'])\r\n            else:\r\n                upcoming_day = \"0\"\r\n                windspeed_upcoming = 0.0\r\n\r\n            best_day_list = [\r\n                best_day_data['conditions'],       # \"Sunny\" (replaced Clear)\r\n                \"Yes\",                             # Yes, it's good to wash clothes\r\n                best_day,                          # Best day (e.g., \"22/09/2024\")\r\n                float(best_day_data['temp']),     # Temperature on the best day\r\n                upcoming_day,                      # Upcoming day (e.g., \"23/09/2024\") or \"0\"\r\n                float(best_day_data['windspeed'])  # Wind speed on the best day\r\n            ]\r\n\r\n            # Send the full best_day_list to InfluxDB\r\n            point = influxdb_client.Point(\"WeatherData\")\\\r\n                .field(\"condition\", best_day_list[0])\\\r\n                .field(\"wash_recommendation\", best_day_list[1])\\\r\n                .field(\"best_day\", best_day_list[2])\\\r\n                .field(\"temperature\", best_day_list[3])\\\r\n                .field(\"upcoming_day\", best_day_list[4])\\\r\n                .field(\"windspeed\", best_day_list[5])\r\n\r\n            # Write point to InfluxDB\r\n            write_api.write(bucket=bucket, org=org, record=point)\r\n\r\n        # Return the list in horizontal format as requested\r\n        return jsonify(best_day_list)\r\n\r\n    except Exception as e:\r\n        return jsonify({\"error\": str(e)}), 500\r\n\r\n\r\nif __name__ == '__main__':\r\n    app.run(debug=True)\r\n",
    "roadmap": {
      "next_problem": "LeetCode #15 - Three Sum",
      "concepts_to_learn": [
        "Advanced Hash Map Usage",
        "Time-Space Optimization"
      ],
      "resources": [
        {
          "type": "video",
          "title": "NeetCode - Hash Maps",
          "link": "https://youtu.be/0ZDYRxBvcm8"
        },
        {
          "type": "article",
          "title": "Hash Table Deep Dive",
          "link": "https://www.geeksforgeeks.org/hashing-data-structure/"
        }
      ],
      "weekly_goal": "Master hash map patterns in 4 problems over 3 days"
    }
  }
]